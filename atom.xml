<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>xiaoka de blogs</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://keminu.com/"/>
  <updated>2017-12-06T00:49:20.801Z</updated>
  <id>http://keminu.com/</id>
  
  <author>
    <name>xiaoka</name>
    <email>keminu@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>精通JavaScript正则之正则原理</title>
    <link href="http://keminu.com/2017/12/03/%E7%B2%BE%E9%80%9AJavaScript%E6%AD%A3%E5%88%99%E4%B9%8B%E6%AD%A3%E5%88%99%E5%8E%9F%E7%90%86/"/>
    <id>http://keminu.com/2017/12/03/精通JavaScript正则之正则原理/</id>
    <published>2017-12-03T07:10:02.000Z</published>
    <updated>2017-12-06T00:49:20.801Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-为什么要知道些正则匹配原理">1、为什么要知道些正则匹配原理</h3>
<p>知其然，知其所以然。</p>
<h3 id="2-正则匹配引擎">2、正则匹配引擎</h3>
<p>正则引擎大体上可分为不同的两类：DFA和NFA。DFA(Deterministic finite automaton) 确定型有穷自动机，NFA (Non-deterministic finite automaton)　非确定型有穷自动机。</p>
<h4 id="21-nfa">2.1 NFA</h4>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">传统的NFA引擎：运行匹配回溯算法——以指定顺序测试正则表达式的所有可能的扩展并接受第一个匹配项。因为传统的 NFA 构造正则表达式的特定扩展以获得成功的匹配，所以它可以捕获子表达式匹配和匹配的反向引用。但传统 NFA的 回溯使它可以访问完全相同的状态多次（如果通过不同的路径到达该状态）。因此，在最坏情况下，它的执行速度可能非常慢。因为传统的 NFA 接受它找到的第一个匹配，所以它还可能会导致其他（可能更长）匹配未被发现。</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">POSIX NFA 引擎：与传统 NFA 引擎类似，不同点：在可以确保已找到了可能的最长的匹配之前，它们将继续回溯（更慢）；并且在使用 POSIX NFA 时，您恐怕不会愿意在更改回溯搜索的顺序的情况下来支持较短的匹配搜索，而非较长的匹配搜索。</div></pre></td></tr></table></figure>
<h4 id="22-dfa">2.2 DFA</h4>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">DFA引擎：在线性时状态下执行，不要求回溯（因此永远不测试相同的字符两次）；确保匹配最长的可能的字符串；因为只包含有限的状态（？），所以它不能匹配具有反向引用的模式；并且因为它不构造显示扩展，所以它不可以捕获子表达式。</div></pre></td></tr></table></figure>
<p>例：</p>
<p>字符串：<strong>this is yansen’s dog</strong></p>
<p>正则表达式：<strong>/ya(msen|nsen|nsem)/</strong></p>
<p>NFA工作方式：先在字符串中查找y，然后匹配其后是否为a； 如果是a则继续查找其后是否为m；如果不是则匹配其后是否为n(此时淘汰msen支分支)； 然后继续看其后是否依次为s,e；接着测试是否为n，是n则匹配成功，不是则测试是否为m。为什么是 m ？因为 NFA 工作方式是以正则表达式为标准，反复测试字符串，这样同样一个字符串有可能被反复测试了很多次！</p>
<p>DFA工作方式：从<strong>this</strong>中<strong>t</strong>开始依次查找<strong>y</strong>，定位到<strong>y</strong>，已知其后为<strong>a</strong>，则查看表达式是否有<strong>a</strong>，此处正好有<strong>a；<strong>然后字符串</strong>a</strong>后为<strong>n</strong>，DFA依次测试表达式，此时<strong>msen</strong>不符合要求淘汰。<strong>nsen</strong>和<strong>nsem</strong>符合要求，然后DFA依次检查字符串，检测到<strong>sen</strong>中的<strong>n</strong>时只有<strong>nsen</strong>分支符合，则匹配成功！</p>
<h3 id="3-基础知识">3、基础知识</h3>
<h4 id="31-字符串组成">3.1 字符串组成</h4>
<p><img src="/Users/kiben/Downloads/35916_12657272630z9X.jpg" alt="35916_12657272630z9X"></p>
<p>对于字符串“<strong>abc</strong>”而言，包括三个字符和四个位置。</p>
<h4 id="32-占有字符和零宽度">3.2 占有字符和零宽度</h4>
<p>正则表达式匹配过程中，如果子表达式匹配到的是字符内容，而非位置，并被保存到最终的匹配结果中，那么就认为这个子表达式是占有字符的；如果子表达式匹配的仅仅是位置，或者匹配的内容并不保存到最终的匹配结果中，那么就认为这个子表达式是零宽度的。</p>
<p>占有字符是互斥的，零宽度是非互斥的。也就是一个字符，同一时间只能由一个子表达式匹配，而一个位置，却可以同时由多个零宽度的子表达式匹配。</p>
<h3 id="33-控制权和传动">3.3  控制权和传动</h3>
<p>正则的匹配过程，通常情况下都是由一个子表达式（可能为一个普通字符、元字符或元字符序列组成）取得控制权，从字符串的某一位置开始尝试匹配，一个子表达式开始尝试匹配的位置，是从前一子表达匹配成功的结束位置开始的。如正则表达式：</p>
<p><strong>(子表达式一)(子表达式二)</strong></p>
<p>假设**(子表达式一)<strong>为零宽度表达式，由于它匹配开始和结束的位置是同一个，如位置0，那么</strong>(子表达式二)**是从位置0开始尝试匹配的。</p>
<p>假设**(子表达式一)<strong>为占有字符的表达式，由于它匹配开始和结束的位置不是同一个，如匹配成功开始于位置0，结束于位置2，那么</strong>(子表达式二)**是从位置2开始尝试匹配的。</p>
<p>而对于整个表达式来说，通常是由字符串位置0开始尝试匹配的。如果在位置0开始的尝试，匹配到字符串某一位置时整个表达式匹配失败，那么引擎会使正则向前传动，整个表达式从位置1开始重新尝试匹配，依此类推，直到报告匹配成功或尝试到最后一个位置后报告匹配失败。</p>
<h3 id="4-正则表达式简单匹配过程">4、正则表达式简单匹配过程</h3>
<h4 id="41-基础匹配过程">4.1 基础匹配过程</h4>
<p>例如：</p>
<p>原字符串：<strong>reg</strong></p>
<p>正则表达式：/reg/</p>
<p>匹配过程：由字符r取得控制权，从位置0开始匹配，由r来匹配<strong>r</strong>，匹配成功，控制权交给字符e，因为之前字符r从位置0已经匹配成功，所以字符e从位置1开始匹配，e匹配<strong>e</strong>，匹配成功，接着到字符g匹配<strong>g</strong>，也匹配成功。</p>
<p>正则表达式匹配完成，匹配结果为<strong>reg</strong>，开始位置0，结束位置3。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-为什么要知道些正则匹配原理&quot;&gt;1、为什么要知道些正则匹配原理&lt;/h3&gt;
&lt;p&gt;知其然，知其所以然。&lt;/p&gt;
&lt;h3 id=&quot;2-正则匹配引擎&quot;&gt;2、正则匹配引擎&lt;/h3&gt;
&lt;p&gt;正则引擎大体上可分为不同的两类：DFA和NFA。DFA(Deterministic
    
    </summary>
    
    
      <category term="正则原理" scheme="http://keminu.com/tags/%E6%AD%A3%E5%88%99%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>精通JavaScript正则之正则基础</title>
    <link href="http://keminu.com/2017/11/05/%E7%B2%BE%E9%80%9AJavaScript%E6%AD%A3%E5%88%99%E4%B9%8B%E6%AD%A3%E5%88%99%E5%9F%BA%E7%A1%80/"/>
    <id>http://keminu.com/2017/11/05/精通JavaScript正则之正则基础/</id>
    <published>2017-11-05T13:23:08.000Z</published>
    <updated>2017-11-05T13:32:07.164Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1正则结构定义">1.正则结构定义</h3>
<p>有两种方式可以定义一个正则表达式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var reg = /pattern/;</div></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var reg = new RegExp(&apos;pattern&apos;);  // 动态匹配</div></pre></td></tr></table></figure>
<h3 id="2正则标识">2.正则标识</h3>
<table>
<thead>
<tr>
<th>标识</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>g</td>
<td>全局（匹配多次；不同的方法对g标识的处理不同）</td>
</tr>
<tr>
<td>i</td>
<td>忽略字符的大小写</td>
</tr>
<tr>
<td>m</td>
<td>匹配多行（在此标识下，^和$能匹配行结束符）</td>
</tr>
</tbody>
</table>
<h3 id="3正则对象属性">3.正则对象属性</h3>
<table>
<thead>
<tr>
<th>属性</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>global</td>
<td>如果标识 g 被使用，值为true</td>
</tr>
<tr>
<td>source</td>
<td>正则表达式源码文本</td>
</tr>
<tr>
<td>ignoreCase</td>
<td>如果标识 i 被使用，值为true</td>
</tr>
<tr>
<td>lastIndex</td>
<td>下一次exec匹配开始的索引。初始值为0</td>
</tr>
<tr>
<td>multiline</td>
<td>如果标识 m 被使用，值为true</td>
</tr>
</tbody>
</table>
<h3 id="4元字符">4.元字符</h3>
<p>字符的类集，比如不确定的数字、任意字符、空白符、结束符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 匹配数字:  \d</div><div class="line">&quot;ad3ad2ad&quot;.match(/\d/g);  // [&quot;3&quot;, &quot;2&quot;]</div><div class="line"></div><div class="line">// 匹配除换行符以外的任意字符:  .</div><div class="line">&quot;a\nb\rc&quot;.match(/./g);  // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</div><div class="line"></div><div class="line">// 匹配字母或数字或下划线 ： \w</div><div class="line">&quot;a5_  汉字@!-=&quot;.match(/\w/g);  // [&quot;a&quot;, &quot;5&quot;, &quot;_&quot;]</div><div class="line"></div><div class="line">// 匹配元音字母的字符组</div><div class="line">&quot;adefglhi&quot;.match(/[aeiou]/g); // [&quot;a&quot;, &quot;e&quot;, &quot;i&quot;, ]</div></pre></td></tr></table></figure>
<p>注意，在字符组内部，一个^表示的是排除组内字符，并不是匹配行开始，就像’|'、-'一样，在字符组内外有着不同的含义</p>
<p>字符组与多选结构的区别：
字符组里面只匹配单个的字符，而多选结构本身就是一个正则</p>
<h3 id="5量词">5.量词</h3>
<p>每一个正则因子都可以用一个正则量词后缀来决定这个因子因该被匹配的次数。包围在一对花括号中的一个数字表示这个因子因该被匹配的次数。？号表示可选，就等同于{0, 1}，*等同于{0, }，+则等同于{1, }。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// 重复0次或多次</div><div class="line">&quot;test&quot;.match(/test\d*/); // [&quot;test&quot;]</div><div class="line">&quot;test123&quot;.match(/test\d*/); // [&quot;test123&quot;]</div></pre></td></tr></table></figure>
<p>从上面的结果可以看到正则匹配的子字符串会尽可能返回多的数字，这就是在满足条件的情况下捕获尽可能多的字符-贪婪模式。</p>
<p>对应的”懒惰模式“，就是在满足条件的情况下捕获尽可能少的字符串，使用懒惰模式的方法，就是在字符重复标识后面加上一个 &quot;?&quot;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 数字重复3~5次，满足条件的情况下返回尽可能少的数字</div><div class="line">&quot;test12345&quot;.match(/test\d&#123;3,5&#125;?/);  // [&quot;test123&quot;]</div><div class="line">// 数字重复1次或更多，满足条件的情况下只返回一个数字</div><div class="line">&quot;test12345&quot;.match(/test\d+?/);  // [&quot;test1&quot;]</div></pre></td></tr></table></figure>
<h3 id="6字符转义">6.字符转义</h3>
<p>在正则表达式中元字符是有特殊的含义的，当我们要匹配元字符本身时，就需要用到字符转义。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/\./.test(&quot;.&quot;); // true</div></pre></td></tr></table></figure>
<h3 id="7分支">7.分支</h3>
<p>当正则表达式需要匹配几种类型的结果时，可以用到分支</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&quot;asdasd hi  asdad hello asdasd&quot;.replace(/hi|hello/,&quot;nihao&quot;); // &quot;asdasd nihao  asdad hello asdasd&quot;</div><div class="line"></div><div class="line">&quot;asdasd hi  asdad hello asdasd&quot;.split(/hi|hello/); // [&quot;asdasd &quot;, &quot;  asdad &quot;, &quot; asdasd&quot;]</div></pre></td></tr></table></figure>
<p>分支条件影响它两边的所有内容， 比如 hi|hello  匹配的是hi或者hello，而不是 hiello 或者 hhello。
分组中的分支条件不会影响分组外的内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&quot;abc acd  bbc bcd &quot;.match(/(a|b)bc/g); // [&quot;abc&quot;, &quot;bbc&quot;]</div></pre></td></tr></table></figure>
<h3 id="8分组">8.分组</h3>
<p>捕获型：一个捕获型分组是一个被包围在圆括号中的正则表达式分支。任何匹配这个分组的字符都会被捕获。每个捕获型分组都被指定了一个数字代表分组号。</p>
<p>非捕获型：非捕获型分组有一个(?:前缀。非捕获型分组仅做简单的匹配，并不会捕获所匹配的文本，也不会干扰捕获型分组的编号。</p>
<p>向前正向匹配：向前正向匹配分组有一个(?=前缀，类似于非捕获型分组，实际上不捕获任何匹配文本，也不分配组号。在这个组匹配后，文本会倒回到它开始的地方。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/hello\s(?=world)/.exec(&quot;asdadasd hello world asdasd&quot;)  // [&quot;hello &quot;]</div></pre></td></tr></table></figure>
<p>向前负向匹配：向前负向匹配分组有一个(?!前缀。它也类似于非捕获型分组，不捕获任何匹配文本，不分配组号。只有当它匹配失败时才继续向前匹配。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/hello\s(?!world)/.exec(&quot;asdadasd hello world asdasd&quot;) // null</div></pre></td></tr></table></figure>
<h3 id="9后向引用">9.后向引用</h3>
<p>正则表达式的分组可以在其后边的语句中通过 \ 紧接着一个数字组号来引用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 匹配重复的单词</div><div class="line">/(\b[a-zA-Z]+\b)\s+\1/.exec(&quot; asd sf  hello hello asd&quot;); // [&quot;hello hello&quot;, &quot;hello&quot;]</div></pre></td></tr></table></figure>
<h3 id="10方法">10.方法</h3>
<h3 id="regexpprototypetest">RegExp.prototype.test</h3>
<p>用来测试字符串中是否含有子字符串</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/hello/.test(&quot;abchello&quot;);  // true</div></pre></td></tr></table></figure>
<h3 id="regexpprototypeexec">RegExp.prototype.exec</h3>
<p>这个方法从字符串中捕获满足条件的字符串到结果数组中，值得注意的是，这个方法一次只能捕获一份子字符串到结果数组中，无论正则表达式是否有全局属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var reg=/hello/g;</div><div class="line">reg.exec(&quot;abchelloasdasdhelloasd&quot;);   // [&quot;hello&quot;]</div></pre></td></tr></table></figure>
<p>如何做全局匹配？</p>
<p>在正则表达式中有分组的情况下，无论正则表达式是否有全局属性，exec函数都只返回一个结果，并捕获分组的结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/h(ell)o/g.exec(&quot;abchellodefhellog&quot;); // [&quot;hello&quot;, &quot;ell&quot;]</div></pre></td></tr></table></figure>
<h3 id="stringprototypesearch">String.prototype.search</h3>
<p>用来找出原字符串中某个子字符串首次出现的index，没有则返回-1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&quot;abchello&quot;.search(/hello/);  // 3</div></pre></td></tr></table></figure>
<h3 id="stringprototypereplace">String.prototype.replace</h3>
<p>用来替换字符串中的子串</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&quot;abchello&quot;.replace(/hello/,&quot;hi&quot;);   // &quot;abchi&quot;</div></pre></td></tr></table></figure>
<p>正则表达式存在分组的情况下，第二个参数里边可以用 $ 紧接着一个数字组号来指代第几个分组的内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&quot; the best language in the world is java &quot;.replace(/(java)/,&quot;$1script&quot;); // &quot; the best language in the world is javascript &quot;</div></pre></td></tr></table></figure>
<h3 id="stringprototypesplit">String.prototype.split</h3>
<p>用来分割字符串</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&quot;abchelloasdasdhelloasd&quot;.split(/hello/);  // [&quot;abc&quot;, &quot;asdasd&quot;, &quot;asd&quot;]</div></pre></td></tr></table></figure>
<h3 id="stringprototypematch">String.prototype.match</h3>
<p>用来捕获字符串中的子字符串到一个数组中。默认情况下只捕获一个结果到数组中，正则表达式有”全局捕获“的属性时(定义正则表达式的时候添加参数g)，会捕获所有结果到数组中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&quot;ahelloasdasdhelloasd&quot;.match(/hello/);  // [&quot;hello&quot;]</div><div class="line"></div><div class="line">&quot;ahelloasdasdhelloasd&quot;.match(/hello/g);  // [&quot;hello&quot;,&quot;hello&quot;]</div></pre></td></tr></table></figure>
<p>当没有全局属性，但是正则表达式有分组时，会返回分组匹配结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&quot;abchellodefhellog&quot;.match(/h(ell)o/); // [&quot;hello&quot;, &quot;ell&quot;]</div></pre></td></tr></table></figure>
<h2 id="一个例子">一个例子</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var parse_url = /^(?:([A-Za-z]+):)?(\/&#123;0,3&#125;)([0-9.\-A-Za-z]+)(?::(\d+))?(?:\/([^?#]*))?(?:\?([^#]*))?(?:#(.*))?$/;</div></pre></td></tr></table></figure>
<h2 id="one-more-thing">One more thing...</h2>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1正则结构定义&quot;&gt;1.正则结构定义&lt;/h3&gt;
&lt;p&gt;有两种方式可以定义一个正则表达式&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;
    
    </summary>
    
    
      <category term="正则表达式" scheme="http://keminu.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>数据双向绑定</title>
    <link href="http://keminu.com/2017/11/05/%E6%95%B0%E6%8D%AE%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/"/>
    <id>http://keminu.com/2017/11/05/数据双向绑定/</id>
    <published>2017-11-05T13:05:01.000Z</published>
    <updated>2017-11-05T13:21:33.978Z</updated>
    
    <content type="html"><![CDATA[<!-- toc -->
<ul>
<li><a href="#1%E6%88%91%E4%BB%AC%E8%A6%81%E5%81%9A%E4%BB%80%E4%B9%88">1.我们要做什么</a></li>
<li><a href="#2objectdefineproperty">2.Object.defineProperty()</a></li>
<li><a href="#3%E4%BF%9D%E5%AD%98%E6%97%A7%E5%80%BC">3.保存旧值</a></li>
<li><a href="#4%E7%9B%91%E6%B5%8B%E6%95%B0%E7%BB%84%E5%8F%98%E5%8C%96">4.监测数组变化</a></li>
<li><a href="#5%E6%A8%A1%E6%9D%BF%E6%98%A0%E5%B0%84">5.模板映射</a></li>
</ul>
<!-- tocstop -->
<h3 id="1我们要做什么">1.我们要做什么</h3>
<p>实现一个迷你库，检测一组数据的变化，当数据变化的时候，做出响应。大致像下面的使用方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">// 定义一个变化通知的回调</div><div class="line">var callback = function(newVal, oldVal)&#123;</div><div class="line">    alert(newVal + &apos;----&apos; + oldVal);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 定义一个普通对象作为数据模型</div><div class="line">var data = &#123;</div><div class="line">    a: 200,</div><div class="line">    level1: &#123;</div><div class="line">        b: &apos;str&apos;,</div><div class="line">        c: [1, 2, 3],</div><div class="line">        level2: &#123;</div><div class="line">            d: 90</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 实例化一个监测对象，去监测数据，并在数据发生改变的时候作出反应</div><div class="line">var v = new Mvvm(data, callback);</div></pre></td></tr></table></figure>
<p>怎么实现？</p>
<h3 id="2objectdefineproperty">2.Object.defineProperty()</h3>
<p>我们可以使用下面的方式定义一个对象，并给对象添加一个属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var obj = &#123;&#125;;</div><div class="line"></div><div class="line">obj.name = &apos;hcy&apos;;</div></pre></td></tr></table></figure>
<p>也可以使用Object.defineProperty()给对象添加属性，上面的代码等价于</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var obj = &#123;&#125;;</div><div class="line"></div><div class="line">Object.defineProperty(obj, &apos;name&apos;, &#123;</div><div class="line">	value: &apos;hcy&apos;,		// 属性的值</div><div class="line">	writable: true,		// 是否可写</div><div class="line">	enumerable: true,	// 是否能够通过for in 枚举</div><div class="line">	configurable: true	// 是否可使用 delete删除</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>这样定义的属性是数据属性，用来描述数据。还有另外一个访问器属性，允许你定义一对儿 getter/setter ，当你读取属性值的时候底层会调用 get 方法，当你去设置属性值的时候，底层会调用 set 方法。</p>
<p>这简直太美妙了，这不正是我们想要的吗？</p>
<p>遍历对象的属性，把对象的属性都使用 Object.defineProperty 转为 getter/setter ，这样，当我们修改一些值得时候，就会调用set方法，然后我们在set方法里面，回调通知，这样不就可以了吗？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">const OP = Object.prototype;</div><div class="line"></div><div class="line">class Mvvm&#123;</div><div class="line">    constructor(obj, callback)&#123;</div><div class="line">        if(OP.toString.call(obj) !== &apos;[object Object]&apos;)&#123;</div><div class="line">            console.error(&apos;This parameter must be an object：&apos; + obj);</div><div class="line">        &#125;</div><div class="line">        this.$callback = callback;</div><div class="line">        this.observe(obj);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    observe(obj)&#123;</div><div class="line">        Object.keys(obj).forEach(function(key, index, keyArray)&#123;</div><div class="line">            var val = obj[key];</div><div class="line">            Object.defineProperty(obj, key, &#123;</div><div class="line">                get: function()&#123;</div><div class="line">                    return val;</div><div class="line">                &#125;,</div><div class="line">                set: (function(newVal)&#123;</div><div class="line">                    this.$callback(newVal);</div><div class="line">                &#125;).bind(this)</div><div class="line">            &#125;);</div><div class="line">            </div><div class="line">            if(OP.toString.call(obj[key]) === &apos;[object Object]&apos;)&#123;</div><div class="line">                this.observe(obj[key]);</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">        &#125;, this);</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="https://jsfiddle.net/keminu/8x3ou6pL/1/" target="_blank" rel="external">测试一下我们的代码</a></p>
<h3 id="3保存旧值">3.保存旧值</h3>
<p>现在我们成功的监测到数据变化并且做出响应了。但是这个响应只处理了新值，有时候我们是需要旧值的，现在我们的代码还无法传递旧值，怎么改？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">var oldVal = obj[key];</div><div class="line">Object.defineProperty(obj, key, &#123;</div><div class="line">    get: function()&#123;</div><div class="line">        return oldVal;</div><div class="line">    &#125;,</div><div class="line">    set: (function(newVal)&#123;</div><div class="line">        if(oldVal !== newVal)&#123;</div><div class="line">            if(OP.toString.call(newVal) === &apos;[object Object]&apos;)&#123;</div><div class="line">                this.observe(newVal);</div><div class="line">            &#125;</div><div class="line">            this.$callback(newVal, oldVal);</div><div class="line">            oldVal = newVal;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">    &#125;).bind(this)</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><a href="https://jsfiddle.net/9hsuz6wa/" target="_blank" rel="external">看下效果</a></p>
<h3 id="4监测数组变化">4.监测数组变化</h3>
<p>这样子看上去还不错了哦，我们能够监测到数据的变化，拿到了新旧数据。但是这样就完了吗？</p>
<p>遗憾的是我们还不能监测到数组的变化。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">data.level1.c.push(4);</div></pre></td></tr></table></figure>
<p>有什么思路可以解决这个问题？
重写原型方法可以吗？像是这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Array.prototype.push = function()&#123;</div><div class="line">    // 数据观察</div><div class="line">&#125;</div><div class="line">Array.prototype.pop = function()&#123;</div><div class="line">    // 数据观察</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>暂且不说能不能全部实现的与原生无异，即使你实现的与原生方法在使用方式上一模一样，并且不影响其他代码的运行，那么在性能上，可能就与原生差很多了，重新考虑，我们可不可以在原型链中加一层fakePrototype，在使用 push 等数组方法的时候，调用的是 fakePrototype 上的push方法，然后在 fakePrototype 方法中再去调用真正的Array原型上的 push 方法，同时监听变化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> *  Object 原型</div><div class="line"> */</div><div class="line">const OP = Object.prototype;</div><div class="line">/*</div><div class="line"> *  需要重写的数组方法 OAR 是 overrideArrayMethod 的缩写</div><div class="line"> */</div><div class="line">const OAM = [&apos;push&apos;, &apos;pop&apos;, &apos;shift&apos;, &apos;unshift&apos;, &apos;splice&apos;, &apos;sort&apos;, &apos;reverse&apos;];</div><div class="line"></div><div class="line">class Mvvm&#123;</div><div class="line">    constructor(obj, callback)&#123;</div><div class="line">        if(OP.toString.call(obj) !== &apos;[object Object]&apos;)&#123;</div><div class="line">            console.error(&apos;This parameter must be an object：&apos; + obj);</div><div class="line">        &#125;</div><div class="line">        this.$callback = callback;</div><div class="line">        this.observe(obj);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    observe(obj)&#123;</div><div class="line">        // 如果发现 监测的对象是数组的话就要调用 overrideArrayProto 方法</div><div class="line">        if(OP.toString.call(obj) === &apos;[object Array]&apos;)&#123;</div><div class="line">            this.overrideArrayProto(obj);</div><div class="line">        &#125;</div><div class="line">        Object.keys(obj).forEach(function(key, index, keyArray)&#123;</div><div class="line">            var oldVal = obj[key];</div><div class="line">            Object.defineProperty(obj, key, &#123;</div><div class="line">                get: function()&#123;</div><div class="line">                    return oldVal;</div><div class="line">                &#125;,</div><div class="line">                set: (function(newVal)&#123;</div><div class="line">                    if(oldVal !== newVal)&#123;</div><div class="line">                        if(OP.toString.call(newVal) === &apos;[object Object]&apos; || OP.toString.call(newVal) === &apos;[object Array]&apos;)&#123;</div><div class="line">                            this.observe(newVal);</div><div class="line">                        &#125;</div><div class="line">                        this.$callback(newVal, oldVal);</div><div class="line">                        oldVal = newVal;</div><div class="line">                    &#125;</div><div class="line">                    </div><div class="line">                &#125;).bind(this)</div><div class="line">            &#125;);</div><div class="line">            </div><div class="line">            if(OP.toString.call(obj[key]) === &apos;[object Object]&apos; || OP.toString.call(obj[key]) === &apos;[object Array]&apos;)&#123;</div><div class="line">                this.observe(obj[key]);</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">        &#125;, this);</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    overrideArrayProto(array)&#123;</div><div class="line">            // 保存原始 Array 原型</div><div class="line">        var originalProto = Array.prototype,</div><div class="line">            // 通过 Object.create 方法创建一个对象，该对象的原型就是Array.prototype</div><div class="line">            overrideProto = Object.create(Array.prototype),</div><div class="line">            self = this,</div><div class="line">            result;</div><div class="line">        // 遍历要重写的数组方法</div><div class="line">        Object.keys(OAM).forEach(function(key, index, array)&#123;</div><div class="line">            var method = OAM[index],</div><div class="line">                oldArray = [];</div><div class="line">            // 使用 Object.defineProperty 给 overrideProto 添加属性，属性的名称是对应的数组函数名，值是函数</div><div class="line">            Object.defineProperty(overrideProto, method, &#123;</div><div class="line">                value: function()&#123;</div><div class="line">                    oldArray = this.slice(0);</div><div class="line">                    </div><div class="line">                    var arg = [].slice.apply(arguments);</div><div class="line">                    // 调用原始 原型 的数组方法</div><div class="line">                    result = originalProto[method].apply(this, arg);</div><div class="line">                    // 对新的数组进行监测</div><div class="line">                    self.observe(this);</div><div class="line">                    // 执行回调</div><div class="line">                    self.$callback(this, oldArray);</div><div class="line">                    </div><div class="line">                    return result;</div><div class="line">                &#125;,</div><div class="line">                writable: true,</div><div class="line">                enumerable: false,</div><div class="line">                configurable: true</div><div class="line">            &#125;);</div><div class="line">        &#125;, this);</div><div class="line">        </div><div class="line">        // 最后 让该数组实例的 __proto__ 属性指向 假的原型 overrideProto</div><div class="line">        array.__proto__ = overrideProto;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="https://jsfiddle.net/keminu/Lv2ycLww/" target="_blank" rel="external">看下效果</a></p>
<h3 id="5模板映射">5.模板映射</h3>
<p>现在，我们可以几乎完美的监测到数据对象的变化了，并且能够知道变化前后的旧值与新值，那么这样就结束了吗？当然不是，我们现在并不知道修改的是哪个属性，但是能够知道修改的是哪个属性是非常重要的。比如，我们有如下的模板：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;div id="box"&gt;</div><div class="line">    &lt;div&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt;</div><div class="line">    &lt;div&gt;&#123;&#123;age&#125;&#125;&lt;/div&gt;</div><div class="line">    &lt;div&gt;&#123;&#123;sex&#125;&#125;&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<p>然后有如下的数据：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> data = &#123;</div><div class="line">    <span class="attr">name</span> : <span class="string">'nuoka'</span>,</div><div class="line">    <span class="attr">age</span> : <span class="number">20</span>,</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们想通过这种方式反应模板与数据之间的关系：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Mvvm(<span class="built_in">document</span>.getElementById(<span class="string">'box'</span>), data);</div></pre></td></tr></table></figure>
<p>那么当我们的数据模型data中的某个属性改变的时候，比如 data.name = ‘kage’，如若我们不知道改变的字段名称，那么我们就无法得知要刷新哪部分模板。</p>
<p>那么这里就有一个路径的概念，所谓路径，就是变化的字段的路径，比如有如下数据模型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var data = &#123;</div><div class="line">    a : &#123;</div><div class="line">        b : &#123;</div><div class="line">            c : &apos;hcy&apos;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么字段 a 的路径就是用 data.a ，b 的路径就是 data.a.b，c 的路径就是 data.a.b.c，这里我们用数组来表述路径可以是这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1、 a 的路径是 [‘data’, ‘a’]</div><div class="line">2、 b 的路径是 [‘data’, ‘a’, ‘b’]</div><div class="line">3、 c 的路径是 [‘data’, ‘a’, ‘b’, ‘c’]</div></pre></td></tr></table></figure>
<p>有了这个概念之后，我们来修改之前的代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line">observe(obj, path)&#123;</div><div class="line">        // 如果发现 监测的对象是数组的话就要调用 overrideArrayProto 方法</div><div class="line">        if(OP.toString.call(obj) === &apos;[object Array]&apos;)&#123;</div><div class="line">            this.overrideArrayProto(obj, path);</div><div class="line">        &#125;</div><div class="line">        Object.keys(obj).forEach(function(key, index, keyArray)&#123;</div><div class="line">            var oldVal = obj[key];</div><div class="line">            </div><div class="line">            var pathArray = path &amp;&amp; path.slice(0);</div><div class="line">            if (pathArray) &#123;</div><div class="line">                pathArray.push(key);</div><div class="line">            &#125; else &#123;</div><div class="line">                pathArray = [key];</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            Object.defineProperty(obj, key, &#123;</div><div class="line">                get: function()&#123;</div><div class="line">                    return oldVal;</div><div class="line">                &#125;,</div><div class="line">                set: (function(newVal)&#123;</div><div class="line">                    if(oldVal !== newVal)&#123;</div><div class="line">                        if(OP.toString.call(newVal) === &apos;[object Object]&apos; || OP.toString.call(newVal) === &apos;[object Array]&apos;)&#123;</div><div class="line">                            this.observe(newVal, pathArray);</div><div class="line">                        &#125;</div><div class="line">                        this.$callback(newVal, oldVal, pathArray);</div><div class="line">                        oldVal = newVal;</div><div class="line">                    &#125;</div><div class="line">                    </div><div class="line">                &#125;).bind(this)</div><div class="line">            &#125;);</div><div class="line">            </div><div class="line">            if(OP.toString.call(obj[key]) === &apos;[object Object]&apos; || OP.toString.call(obj[key]) === &apos;[object Array]&apos;)&#123;</div><div class="line">                this.observe(obj[key], pathArray);</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">        &#125;, this);</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    overrideArrayProto(array, path)&#123;</div><div class="line">            // 保存原始 Array 原型</div><div class="line">        var originalProto = Array.prototype,</div><div class="line">            // 通过 Object.create 方法创建一个对象，该对象的原型就是Array.prototype</div><div class="line">            overrideProto = Object.create(Array.prototype),</div><div class="line">            self = this,</div><div class="line">            result;</div><div class="line">        // 遍历要重写的数组方法</div><div class="line">        Object.keys(OAM).forEach(function(key, index, array)&#123;</div><div class="line">            var method = OAM[index],</div><div class="line">                oldArray = [];</div><div class="line">            // 使用 Object.defineProperty 给 overrideProto 添加属性，属性的名称是对应的数组函数名，值是函数</div><div class="line">            Object.defineProperty(overrideProto, method, &#123;</div><div class="line">                value: function()&#123;</div><div class="line">                    oldArray = this.slice(0);</div><div class="line">                    </div><div class="line">                    var arg = [].slice.apply(arguments);</div><div class="line">                    // 调用原始 原型 的数组方法</div><div class="line">                    result = originalProto[method].apply(this, arg);</div><div class="line">                    // 对新的数组进行监测</div><div class="line">                    self.observe(this, path);</div><div class="line">                    // 执行回调</div><div class="line">                    self.$callback(this, oldArray, path);</div><div class="line">                    </div><div class="line">                    return result;</div><div class="line">                &#125;,</div><div class="line">                writable: true,</div><div class="line">                enumerable: false,</div><div class="line">                configurable: true</div><div class="line">            &#125;);</div><div class="line">        &#125;, this);</div><div class="line">        </div><div class="line">        // 最后 让该数组实例的 __proto__ 属性指向 假的原型 overrideProto</div><div class="line">        array.__proto__ = overrideProto;</div><div class="line">        </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><a href="https://jsfiddle.net/keminu/o0zavhy9/" target="_blank" rel="external">最后再尝试下修改数组属性</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1%E6%88%91%E4%BB%AC%E8%A6%81%E5%81%9A%E4%BB%80%E4%B9%88&quot;&gt;1.我们要做什么&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2objectdefineproper
    
    </summary>
    
    
      <category term="vue" scheme="http://keminu.com/tags/vue/"/>
    
      <category term="响应式原理" scheme="http://keminu.com/tags/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>在工作遇到的IE8兼容性问题</title>
    <link href="http://keminu.com/2016/07/02/%E5%9C%A8%E5%B7%A5%E4%BD%9C%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84IE8%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98/"/>
    <id>http://keminu.com/2016/07/02/在工作中遇到的IE8兼容性问题/</id>
    <published>2016-07-02T12:33:30.000Z</published>
    <updated>2017-05-30T13:35:40.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc -->
<ul>
<li><a href="#1-ie8%E4%B8%8D%E5%85%BC%E5%AE%B9es5%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B9%E6%B3%95%E6%AF%94%E5%A6%82indexoflastindexoffilter%E7%AD%89%E7%AD%89">1、IE8不兼容ES5的一些方法，比如indexOf,lastIndexOf,filter等等</a></li>
<li><a href="#2-ie8%E4%B8%8D%E5%85%BC%E5%AE%B9opacity-rgba%E5%B1%9E%E6%80%A7">2、IE8不兼容opacity、rgba属性</a></li>
<li><a href="#3-ie8%E4%B8%8D%E5%85%BC%E5%AE%B9border-radius%E5%B1%9E%E6%80%A7">3、IE8不兼容border-radius属性</a></li>
</ul>
<!-- tocstop -->
<h2 id="1-ie8不兼容es5的一些方法比如indexoflastindexoffilter等等">1、IE8不兼容ES5的一些方法，比如indexOf,lastIndexOf,filter等等</h2>
<p>解决方法：添加es5-shim.js脚本，在github搜索相应关键字。</p>
<h2 id="2-ie8不兼容opacity-rgba属性">2、IE8不兼容opacity、rgba属性</h2>
<p>解决方法：使用ie的过滤器filter</p>
<h2 id="3-ie8不兼容border-radius属性">3、IE8不兼容border-radius属性</h2>
<p>尝试使用border-radius.htc这个hack，但是还是没有效果，暂时还不知道是什么原因。
又尝试使用jquery.corner.js，还是没有解决。</p>
]]></content>
    
    <summary type="html">
    
      一些在工作过程中遇到的IE8兼容性问题，以及相应的解决方案。
    
    </summary>
    
      <category term="IE8兼容性" scheme="http://keminu.com/categories/IE8%E5%85%BC%E5%AE%B9%E6%80%A7/"/>
    
    
      <category term="css" scheme="http://keminu.com/tags/css/"/>
    
      <category term="IE8兼容性" scheme="http://keminu.com/tags/IE8%E5%85%BC%E5%AE%B9%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>你为什么要开始写博客</title>
    <link href="http://keminu.com/2016/06/26/%E4%BD%A0%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%BC%80%E5%A7%8B%E5%86%99%E5%8D%9A%E5%AE%A2/"/>
    <id>http://keminu.com/2016/06/26/你为什么要开始写博客/</id>
    <published>2016-06-26T08:33:30.000Z</published>
    <updated>2017-11-05T13:08:39.802Z</updated>
    
    <content type="html"><![CDATA[<!-- toc -->
<ul>
<li><a href="#1-%E6%80%BB%E7%BB%93%E8%87%AA%E5%B7%B1%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%94%9F%E6%B4%BB">1、总结自己的学习生活</a></li>
<li><a href="#2-%E8%AE%A9%E5%88%AB%E4%BA%BA%E6%9B%B4%E5%8A%A0%E4%BA%86%E8%A7%A3%E8%87%AA%E5%B7%B1">2、让别人更加了解自己</a></li>
<li><a href="#3-%E5%86%99%E5%8D%9A%E5%AE%A2%E6%98%AF%E8%AE%AD%E7%BB%83%E8%87%AA%E5%B7%B1%E6%80%9D%E7%BB%B4%E7%9A%84%E4%B8%80%E7%A7%8D%E6%96%B9%E5%BC%8F">3、写博客是训练自己思维的一种方式</a></li>
</ul>
<!-- tocstop -->
<h2 id="1-总结自己的学习生活">1、总结自己的学习生活</h2>
<p>把近期学习过的知识再梳理一遍，梳理的过程中会不断的回忆已学知识，会去扩展调查取证来证明自己的观点，这样不仅能够巩固牢记之前所学，还会让自己的逻辑性更强</p>
<h2 id="2-让别人更加了解自己">2、让别人更加了解自己</h2>
<p>在这个互联网时代，要学会展现自己，让不了解自己的人更加的了解自己。博客就是一种很好的方式。</p>
<h2 id="3-写博客是训练自己思维的一种方式">3、写博客是训练自己思维的一种方式</h2>
<p>写出来的博客必须要具有总结性、连贯性、逻辑性。
总结性需要高度的概括能力，精确的提炼关键信息。
连贯性与逻辑性是相辅相成的，连贯性是建立在逻辑性的基础之上，而是否符合逻辑很大程度上取决于知识面，知识面越广，理解越透彻，写出来的文章才不是被他人轻易的推倒。</p>
]]></content>
    
    <summary type="html">
    
      在此写下我开始写博客的几点原由，对自己进行一些总结。
    
    </summary>
    
      <category term="hexo" scheme="http://keminu.com/categories/hexo/"/>
    
    
      <category term="思维方式" scheme="http://keminu.com/tags/%E6%80%9D%E7%BB%B4%E6%96%B9%E5%BC%8F/"/>
    
  </entry>
  
</feed>
