<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>xiaoka de blogs</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://keminu.com/"/>
  <updated>2018-07-09T14:14:45.173Z</updated>
  <id>http://keminu.com/</id>
  
  <author>
    <name>xiaoka</name>
    <email>keminu@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>web安全（一）</title>
    <link href="http://keminu.com/2018/07/08/web%E5%AE%89%E5%85%A8/"/>
    <id>http://keminu.com/2018/07/08/web安全/</id>
    <published>2018-07-08T02:59:17.000Z</published>
    <updated>2018-07-09T14:14:45.173Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-数据流输入输出">1、数据流输入输出</h3>
<p>我们可以从一个数据输入输出流中，查看web安全的整体是怎么样的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1. 如果在操作系统层上没处理好，比如Linux的Bash环境把“特殊数据”当做指令执行时，就产生了OS命令执行的安全问题，这段“特殊数据”可能长得如下这般：; rm -rf /;</div><div class="line">2. 如果在存储层的数据库中没处理好，数据库的SQL解析引擎把这个“特殊数据”当做指令执行时，就产生SQL注入这样的安全问题，这段“特殊数据”可能长得如下这般：&apos; union select user, pwd, 1, 2, 3, 4 from users--</div><div class="line">3. 如果在Web容器层如nginx中没处理好，nginx把“特殊数据”当做指令执行时，可能会产生远程溢出、DoS等各种安全问题，这段“特殊数据”可能长得如下这般：%c0.%c0./%c0.%c0./%c0.%c0./%c0.%c0./%20</div><div class="line">4. 如果在Web开发框架或Web应用层中没处理好，把“特殊数据”当做指令执行时，可能会产生远程命令执行的安全问题，这段“特殊数据”可能长得如下这般：eval($_REQUEST[&apos;x&apos;]);</div><div class="line">5. 如果在Web前端层中没处理好，浏览器的JS引擎把“特殊数据”当做指令执行时，可能会产生XSS跨站脚本的安全问题，这段“特殊数据”可能长得如下这般：&apos;&quot;&gt;&lt;script&gt;alert(/cos is my hero./)&lt;/script&gt;</div></pre></td></tr></table></figure>
<h3 id="2-ddos攻击">2、DDoS攻击</h3>
<p>DoS(Denial of Service)，即拒绝服务，造成远程服务器拒绝服务的行为被称为DoS攻击。其目的是使计算机或网络无法提供正常的服务。最常见的DoS攻击有计算机网络带宽攻击和连通性攻击。攻击的问题就出在TCP连接的三次握手中，假设一个用户向服务器发送了SYN报文后突然死机或掉线，那么服务器在发出SYN+ACK应答报文后是无法收到客户端的ACK报文的，从而导致第三次握手无法完成。在这种情况下服务器端一般会重试，即再次发送SYN+ACK给客户端，并等待一段时间后丢弃这个未完成的连接。这段时间的长度我们称为SYN Timeout，一般来说这个时间是分钟的数量级，大约为30秒到2分钟。一个用户出现异常导致服务器的一个线程等待1分钟并不是什么很大的问题，但如果有一个恶意的攻击者大量模拟这种情况，服务器端将为了维护一个非常大的半连接列表而消耗非常多的资源，即数以万计的半连接，将会对服务器的CPU和内存造成极大的消耗。若服务器的TCP/IP栈不够强大，最后的结果往往是堆栈溢出崩溃。实际上，就算服务器端的系统足够强大，服务器端也将忙于处理攻击者伪造的TCP连接请求而无暇理睬客户的正常请求，导致用户的正常请求失去响应。</p>
<p>对于DDoS攻击，我们可以做如下防范：</p>
<p>(1) 反欺骗：对数据包的地址及端口的正确性进行验证，同时进行反向探测。</p>
<p>(2) 协议栈行为模式分析：每个数据包类型需要符合RFC规定，这就好像每个数据包都要有完整规范的着装，只要不符合规范，就自动识别并将其过滤掉。</p>
<p>(3) 特定应用防护：非法流量总是有一些特定特征的，这就好比即便你混进了顾客群中，但你的行为还是会暴露出你的动机，比如老重复问店员同一个问题，老做同样的动作，这样你仍然还是会被发现的。</p>
<p>(4) 带宽控制：真实的访问数据过大时，可以限制其最大输出的流量，以减少下游网络系统的压力</p>
<h3 id="3-跨站脚本攻击xss">3、跨站脚本攻击（XSS）</h3>
<p>XSS(Cross Site Scripting)，跨站脚本攻击。为和层叠样式表(Cascading Style Sheets，CSS)区分开，跨站脚本在安全领域叫做“XSS”。恶意攻击者往Web页面里注入恶意Script代码，当用户浏览这些网页时，就会执行其中的恶意代码，可对用户进行盗取cookie信息、会话劫持等各种攻击。XSS是常见的Web攻击技术之一，由于跨站脚本漏洞易于出现且利用成本低，所以被OWASP列为当前的头号Web安全威胁。</p>
<p>根据XSS攻击的效果，可以将XSS分为3类：</p>
<p>(1) 反射型XSS(Non-persistent XSS)，服务器接受客户端的请求包，不会存储请求包的内容，只是简单的把用户输入的数据“反射”给浏览器。例如：www.a.com?xss.php?name=</p>
<script>alert(document.cookie, '哈哈，你的cookie我已经拿到')</script>。访问这个链接则会弹出页面的cookie内容，若攻击者把alert改为一个精心构造的发送函数，就可以把用户的cookie偷走。
<p>(2) 存储型XSS(Persistent XSS)，这类XSS攻击会把用户输入的数据“存储”在服务器端，具有很强的稳定性。注入脚本跟反射型XSS大同小异，只是脚本不是通过浏览器à服务器à浏览器这样的反射方式，而是多发生在富文本编辑器、日志、留言、配置系统等数据库保存用户输入内容的业务场景。即用户的注入脚本保存到了数据库里，其他用户进行访问涉及到包含恶意脚本的链接都会中招。由于这段恶意的脚本被上传保存到了服务器，这种XSS攻击就叫做“存储型XSS”。例如：</p>
<p>服务器端代码：<?php $db.set(‘name’, $_GET[‘name’]);?></p>
<p>HTML页面代码：<?php echo ‘Hi,’ . $db.get[‘name’];?></p>
<p>对于XSS攻击，我们可以做如下防范：</p>
<p>(1) 输入过滤。永远不要相信用户的输入，对用户输入的数据做一定的过滤。如输入的数据是否符合预期的格式，比如日期格式，Email格式，电话号码格式等等。这样可以初步对XSS漏洞进行防御。</p>
<p>上面的措施只在web端做了限制，攻击者通抓包工具如Fiddler还是可以绕过前端输入的限制，修改请求注入攻击脚本。因此，后台服务器需要在接收到用户输入的数据后，对特殊危险字符进行过滤或者转义处理，然后再存储到数据库中。</p>
<p>(2) 输出编码。服务器端输出到浏览器的数据，可以使用系统的安全函数来进行编码或转义来防范XSS攻击。在PHP中，有htmlentities()和htmlspecialchars()两个函数可以满足安全要求。相应的JavaScript的编码方式可以使用JavascriptEncode。</p>
<p>(3) 安全编码。开发需尽量避免Web客户端文档重写、重定向或其他敏感操作，同时要避免使用客户端数据，这些操作需尽量在服务器端使用动态页面来实现。</p>
<p>(4) HttpOnly Cookie。预防XSS攻击窃取用户cookie最有效的防御手段。Web应用程序在设置cookie时，将其属性设为HttpOnly，就可以避免该网页的cookie被客户端恶意JavaScript窃取，保护用户cookie信息。</p>
<p>(5)WAF(Web Application Firewall)，Web应用防火墙，主要的功能是防范诸如网页木马、XSS以及CSRF等常见的Web漏洞攻击。由第三方公司开发，在企业环境中深受欢迎。</p>
<h3 id="4-跨站点请求伪造csrf">4、跨站点请求伪造（CSRF）</h3>
<p>CSRF(Cross Site Request Forgery)，即跨站请求伪造，是一种常见的Web攻击，但很多开发者对它很陌生。CSRF也是Web安全中最容易被忽略的一种攻击。下面先介绍一下CSRF攻击的原理。</p>
<p>受害者用户登录网站A，输入个人信息，在本地保存服务器生成的cookie。攻击者构建一条恶意链接，例如对受害者在网站A的信息及状态进行操作，典型的例子就是转账。受害者打开了攻击者构建的网页B，浏览器发出该恶意连接的请求，浏览器发起会话的过程中发送本地保存的cookie到网址A，A网站收到cookie，以为此链接是受害者发出的操作，导致受害者的身份被盗用，完成攻击者恶意的目的。</p>
<p>举个简单的例子来说明下CSRF的危害。用户登陆某银行网站，以Get请求的方式完成到另一银行的转账，如：http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000。攻击者可构造另一危险链接http://www.mybank.com/Transfer.php?toUserId=100&amp;money=1000并把该链接通过一定方式发给受害者用户。受害者用户若在浏览器打开此链接，会将之前登陆后的cookie信息一起发送给银行网站，服务器在接收到该请求后，确认cookie信息无误，会完成改请求操作，造成攻击行为完成。攻击者可以构造CGI的每一个参数，伪造请求。这也是存在CSRF漏洞的最本质原因。</p>
<p>对于CSRF攻击，我们可以做如下防范：</p>
<p>(1) 验证码。应用程序和用户进行交互过程中，特别是账户交易这种核心步骤，强制用户输入验证码，才能完成最终请求。在通常情况下，验证码够很好地遏制CSRF攻击。</p>
<p>但增加验证码降低了用户的体验，网站不能给所有的操作都加上验证码。所以只能将验证码作为一种辅助手段，在关键业务点设置验证码。</p>
<p>(2) Referer Check。HTTP Referer是header的一部分，当浏览器向web服务器发送请求时，一般会带上Referer信息告诉服务器是从哪个页面链接过来的，服务器籍此可以获得一些信息用于处理。可以通过检查请求的来源来防御CSRF攻击。正常请求的referer具有一定规律，如在提交表单的referer必定是在该页面发起的请求。所以通过检查http包头referer的值是不是这个页面，来判断是不是CSRF攻击。</p>
<p>但在某些情况下如从https跳转到http，浏览器处于安全考虑，不会发送referer，服务器就无法进行check了。若与该网站同域的其他网站有XSS漏洞，那么攻击者可以在其他网站注入恶意脚本，受害者进入了此类同域的网址，也会遭受攻击。出于以上原因，无法完全依赖Referer Check作为防御CSRF的主要手段。但是可以通过Referer Check来监控CSRF攻击的发生。</p>
<p>(3) Anti CSRF Token。目前比较完善的解决方案是加入Anti-CSRF-Token，即发送请求时在HTTP 请求中以参数的形式加入一个随机产生的token，并在服务器建立一个拦截器来验证这个token。服务器读取浏览器当前域cookie中这个token值，会进行校验该请求当中的token和cookie当中的token值是否都存在且相等，才认为这是合法的请求。否则认为这次请求是违法的，拒绝该次服务。</p>
<h3 id="5-点击劫持clickjacking">5、点击劫持（ClickJacking）</h3>
<p>点击攻击就是一种视觉上的欺骗。攻击者用一个透明的不可见的iframe，覆盖在一个网页上，用户在不知情的情况下，点击透明的iframe。</p>
<h3 id="6-数据库注入攻击">6、数据库注入攻击</h3>
<p>SQL注入(SQL Injection)，应用程序在向后台数据库传递SQL(Structured Query Language，结构化查询语言)时，攻击者将SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。</p>
<p>SQL注入常见产生的原因有：</p>
<p>(1) 转义字符处理不当。特别是输入验证和单引号处理不当。用户简单的在url页面输入一个单引号，就能快速识别Web站点是否易收到SQL注入攻击。</p>
<p>(2) 后台查询语句处理不当。开发者完全信赖用户的输入，未对输入的字段进行判断和过滤处理，直接调用用户输入字段访问数据库。</p>
<p>(3) SQL语句被拼接。攻击者构造精心设计拼接过的SQL语句，来达到恶意的目的。如构造语句：select * from users where userid=123; DROP TABLE users;直接导致user表被删除。</p>
<h3 id="7-文件上传漏洞">7、文件上传漏洞</h3>
<p>上传漏洞在DVBBS6.0时代被黑客们利用的最为猖獗，利用上传漏洞可以直接得到WEBSHELL，危害等级超级高，现在的入侵中上传漏洞也是常见的漏洞。该漏洞允许用户上传任意文件可能会让攻击者注入危险内容或恶意代码，并在服务器上运行。</p>
<p>文件上传漏洞的原理：由于文件上传功能实现代码没有严格限制用户上传的文件后缀以及文件类型，导致允许攻击者向某个可通过 Web 访问的目录上传任意PHP文件，并能够将这些文件传递给 PHP 解释器，就可以在远程服务器上执行任意PHP脚本。</p>
<p>对于文件上传漏洞攻击，我们可以做如下防范：</p>
<p>(1)检查服务器是否判断了上传文件类型及后缀。</p>
<p>(2) 定义上传文件类型白名单，即只允许白名单里面类型的文件上传。</p>
<p>(3) 文件上传目录禁止执行脚本解析，避免攻击者进行二次攻击。</p>
<h3 id="参考资料">参考资料</h3>
<p>《白帽子讲web安全》</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-数据流输入输出&quot;&gt;1、数据流输入输出&lt;/h3&gt;
&lt;p&gt;我们可以从一个数据输入输出流中，查看web安全的整体是怎么样的。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre
    
    </summary>
    
    
      <category term="web安全" scheme="http://keminu.com/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>理解JavaScript之函数创建过程</title>
    <link href="http://keminu.com/2018/06/09/%E7%90%86%E8%A7%A3JavaScript%E4%B9%8B%E5%87%BD%E6%95%B0%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B/"/>
    <id>http://keminu.com/2018/06/09/理解JavaScript之函数创建过程/</id>
    <published>2018-06-09T08:32:54.000Z</published>
    <updated>2018-06-09T09:01:46.332Z</updated>
    
    <content type="html"><![CDATA[<p>为了更好的了解JavaScript函数的执行，看了下ECMAScript标准有关函数的创建过程。</p>
<p>下面的伪代码展现了函数的创建算法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 解释了原型链最顶部的类型</span></div><div class="line">F = <span class="keyword">new</span> NativeObject();</div><div class="line">  </div><div class="line"><span class="comment">// property [[Class]] is "Function"</span></div><div class="line">F.[[Class]] = <span class="string">"Function"</span></div><div class="line">  </div><div class="line"><span class="comment">// a prototype of a function object</span></div><div class="line">F.[[Prototype]] = <span class="built_in">Function</span>.prototype</div><div class="line">  </div><div class="line"><span class="comment">// reference to function itself</span></div><div class="line"><span class="comment">// [[Call]] is activated by call expression F()</span></div><div class="line"><span class="comment">// and creates a new execution context</span></div><div class="line"><span class="comment">// 函数调用时执行[[Call]]，并创建执行上下文</span></div><div class="line">F.[[Call]] = &lt;reference to function&gt;</div><div class="line">  </div><div class="line">// built in general constructor of objects</div><div class="line">// [[Construct]] is activated via "new" keyword</div><div class="line">// and it is the one who allocates memory for new</div><div class="line">// objects; then it calls F.[[Call]]</div><div class="line">// to initialize created objects passing as</div><div class="line">// "this" value newly created object </div><div class="line">// 当使用 new 操作符时会调用[[Construct]]，并为新的对象分配内存，再调用[[Call]]</div><div class="line">F.[[Construct]] = internalConstructor</div><div class="line">  </div><div class="line">// scope chain of the current context</div><div class="line">// i.e. context which creates function F</div><div class="line">// 这里说明了使用new操作符与直接调用的不同，</div><div class="line">// 不同的原型链，不同的this指向</div><div class="line">F.[[Scope]] = activeContext.Scope</div><div class="line">// if this functions is created </div><div class="line">// via new Function(...), then</div><div class="line">F.[[Scope]] = globalContext.Scope</div><div class="line">  </div><div class="line">// number of formal parameters</div><div class="line">// 函数参数</div><div class="line">F.length = countParameters</div><div class="line">  </div><div class="line">// a prototype of created by F objects</div><div class="line">__objectPrototype = new Object();</div><div class="line">__objectPrototype.constructor = F // &#123;DontEnum&#125;, is not enumerable in loops</div><div class="line">F.prototype = __objectPrototype</div><div class="line">  </div><div class="line">return F</div></pre></td></tr></table></figure>
<p>需要注意的是，*F.[[Prototype]]*是函数(构造器)的原型，也被这个函数所创建的对象的原型。怎么翻译都感觉不对，自己体会吧。(<em>F.[[Prototype]]</em> is a prototype of the <em>function (constructor)</em> and <em>F.prototype</em> is a prototype <em>of objects created by this function</em>)</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为了更好的了解JavaScript函数的执行，看了下ECMAScript标准有关函数的创建过程。&lt;/p&gt;
&lt;p&gt;下面的伪代码展现了函数的创建算法。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://keminu.com/tags/JavaScript/"/>
    
      <category term="函数" scheme="http://keminu.com/tags/%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>理解JavaScript之创建对象</title>
    <link href="http://keminu.com/2018/06/03/%E7%90%86%E8%A7%A3JavaScript%E4%B9%8B%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/"/>
    <id>http://keminu.com/2018/06/03/理解JavaScript之创建对象/</id>
    <published>2018-06-03T02:09:49.000Z</published>
    <updated>2018-06-08T00:00:22.971Z</updated>
    
    <content type="html"><![CDATA[<p>翻看了之前的文章，有说到，如果有一个对象的访问链是这样的<em>a.b.c</em>，那么其实它可以用数组来表示，写为[a, b, c]。要达到<em>a.b.c</em>转为*[a, b, c]<em>是比较简单的，只需要遍历</em>a*的所有可枚举的属性，再push到一个数组里面。</p>
<p>好了，现在考虑这样一个场景，在一颗树中，我搜索出了<em>c</em>的路径为*[a, b, c]<em>，如何把它转化为一个对象</em>a.b.c*？</p>
<p>为了解决这个问题，去复习了下对象的创建方式，这篇文章更像是笔记。</p>
<p>说了那么多的废话，现在开始吧。下面都是参考《JavaScript高级程序设计》。</p>
<h3 id="1-工厂模式">1、工厂模式</h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">    o.name = name;</div><div class="line">    o.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> o;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = createPerson(<span class="string">'kevin'</span>);</div></pre></td></tr></table></figure>
<p>这种方式所有的对象都是从一个函数创建的。所有的实例都指向一个原型，对象无法识别。</p>
<h3 id="2-构造函数模式">2、构造函数模式</h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">'kevin'</span>);</div></pre></td></tr></table></figure>
<p>这种方式的实例可以识别为一个特定的类型，但是每次创建实例时，每个方法都要被创建一次。</p>
<h3 id="21-构造函数模式优化">2.1、构造函数模式优化</h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.getName = getName;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">'kevin'</span>);</div></pre></td></tr></table></figure>
<p>这种方式解决了创建实例时，每个方法都要被创建一次的问题，但是，这代码。。</p>
<h3 id="3-原型模式">3、原型模式</h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">Person.prototype.name = <span class="string">'keivn'</span>;</div><div class="line">Person.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</div></pre></td></tr></table></figure>
<p>这样的话，原型方法不会被重新创建，但是所有的属性和方法都是被共享的，很多自定义参数也不能初始化。</p>
<h3 id="31-原型模式优化1">3.1、原型模式优化1</h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">Person.prototype = &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">'kevin'</span>,</div><div class="line">    <span class="attr">getName</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</div></pre></td></tr></table></figure>
<p>封装性好了一点，但是重写了原型，丢失了constructor属性。</p>
<h3 id="32-原型模式优化2">3.2、原型模式优化2</h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">Person.prototype = &#123;</div><div class="line">    <span class="attr">constructor</span>: Person,</div><div class="line">    <span class="attr">name</span>: <span class="string">'kevin'</span>,</div><div class="line">    <span class="attr">getName</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</div></pre></td></tr></table></figure>
<p>保留了构造函数，但是所有的属性和参数还是被共享。</p>
<h3 id="4-组合模式">4、组合模式</h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Person.prototype = &#123;</div><div class="line">    <span class="attr">constructor</span>: Person,</div><div class="line">    <span class="attr">getName</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</div></pre></td></tr></table></figure>
<p>构造函数模式与原型模式的组合，该共享的共享，该私有的私有，使用最广泛的方式。但是有人就喜欢有更好的封装，所有的东西写在一块。</p>
<h3 id="41-动态原型模式">4.1、动态原型模式</h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.getName != <span class="string">"function"</span>) &#123;</div><div class="line">        Person.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</div></pre></td></tr></table></figure>
<p>使用这种方式时，不能用对象字面量重写原型。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.getName != <span class="string">"function"</span>) &#123;</div><div class="line">        Person.prototype = &#123;</div><div class="line">            <span class="attr">constructor</span>: Person,</div><div class="line">            <span class="attr">getName</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">                <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">'kevin'</span>);</div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">'daisy'</span>);</div><div class="line"></div><div class="line"><span class="comment">// 报错 并没有该方法</span></div><div class="line">person1.getName();</div><div class="line"></div><div class="line"><span class="comment">// 注释掉上面的代码，这句是可以执行的。</span></div><div class="line">person2.getName();</div></pre></td></tr></table></figure>
<p>使用字面量方式直接覆盖 Person.prototype，并不会更改原来实例的原型的值，person1 依然是指向了以前的原型，而不是 Person.prototype。而之前的原型是没有 getName 方法的，所以就报错了！</p>
<h3 id="51-寄生构造函数模式">5.1、寄生构造函数模式</h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">    o.name = name;</div><div class="line">    o.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> o;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">'kevin'</span>);</div><div class="line"><span class="built_in">console</span>.log(person1 <span class="keyword">instanceof</span> Person) <span class="comment">// false</span></div><div class="line"><span class="built_in">console</span>.log(person1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>)  <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>就是寄生在构造函数中的一种模式，应用场景在于比如我们想创建一个具有额外方法的特殊数组，但是又不想直接修改Array构造函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SpecialArray</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> array = <span class="keyword">new</span> <span class="built_in">Array</span>();</div><div class="line"></div><div class="line">    array.selfFn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> array;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="52-稳妥构造函数模式">5.2、稳妥构造函数模式</h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">person</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">    o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(name);</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> o;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = person(<span class="string">'kevin'</span>);</div><div class="line"></div><div class="line">person1.sayName(); <span class="comment">// kevin</span></div><div class="line"></div><div class="line">person1.name = <span class="string">"daisy"</span>;</div><div class="line"></div><div class="line">person1.sayName(); <span class="comment">// kevin</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person1.name); <span class="comment">// daisy</span></div></pre></td></tr></table></figure>
<p>所谓稳妥，指的是没有公共属性，而且其方法也不引用 this 的对象。适合在一些安全的环境中。</p>
<p>每一种模式都对应着不同的应用场景，我们使用的最多的应该是组合模式。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;翻看了之前的文章，有说到，如果有一个对象的访问链是这样的&lt;em&gt;a.b.c&lt;/em&gt;，那么其实它可以用数组来表示，写为[a, b, c]。要达到&lt;em&gt;a.b.c&lt;/em&gt;转为*[a, b, c]&lt;em&gt;是比较简单的，只需要遍历&lt;/em&gt;a*的所有可枚举的属性，再push到
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://keminu.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>理解JavaScript之数组去重</title>
    <link href="http://keminu.com/2018/05/06/%E7%90%86%E8%A7%A3JavaScript%E4%B9%8B%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/"/>
    <id>http://keminu.com/2018/05/06/理解JavaScript之数组去重/</id>
    <published>2018-05-06T02:24:04.000Z</published>
    <updated>2018-05-06T16:05:36.665Z</updated>
    
    <content type="html"><![CDATA[<p>在大量的数据处理中，我们经常会使用到数据去重，得到唯一数组，以便展示。下面来看看常用的几种数组去重的方式。</p>
<h4 id="1-循环遍历">1、循环遍历</h4>
<p>在这种方式中，通过源数组与目标数组进行比较，来判断源数组的元素在目标数组中是否唯一存在。上代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> sourceArray = [<span class="string">'1'</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="string">'1'</span>, <span class="number">2</span>, <span class="number">2</span>];</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">sourceArray</span>) </span>&#123;</div><div class="line">    <span class="comment">// targetArray用来存储结果</span></div><div class="line">    <span class="keyword">let</span> targetArray = [];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, sourceArrayLen = sourceArray.length; i &lt; sourceArrayLen; i++) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>, targetArrayLen = targetArray.length; j &lt; targetArrayLen; j++ ) &#123;</div><div class="line">            <span class="keyword">if</span> (sourceArray[i] === targetArray[j]) &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 如果sourceArray[i]是唯一的，那么执行完循环，j等于targetArrayLen</span></div><div class="line">        <span class="keyword">if</span> (j === targetArrayLen) &#123;</div><div class="line">            targetArray.push(sourceArray[i])</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> targetArray;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(unique(sourceArray)); <span class="comment">// ['1', 1, 2]</span></div></pre></td></tr></table></figure>
<p>在内循环中，如果sourceArray[i] 与 targetArray[j] 的值不相等，说明元素是唯一的，这时候，j的值就会等于targetArray的长度。</p>
<p>在数组中检测某个元素是否存在，可以使用indexOf方法，这样便可以简化内循环。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">sourceArray</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> targetArray = [];</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = sourceArray.length; i &lt; len; i++) &#123;</div><div class="line">    <span class="keyword">const</span> current = sourceArray[i];</div><div class="line">    <span class="keyword">if</span> (targetArray.indexOf(current) === <span class="number">-1</span>) &#123;</div><div class="line">      targetArray.push(current)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> targetArray;</div><div class="line">&#125;</div><div class="line"><span class="keyword">const</span> sourceArray = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>];</div><div class="line"><span class="built_in">console</span>.log(unique(sourceArray)); <span class="comment">// ['1', 1, 2]</span></div></pre></td></tr></table></figure>
<h4 id="2-排序后去重">2、排序后去重</h4>
<p>对于一个已经排序的数组，上面的方法显得效率有点低下，因为我们只需判断当前元素与上一个元素是否相同，不需要再进行循环。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">sourceArray</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> targetArray = [];</div><div class="line">  <span class="keyword">const</span> sortedSourceArray = sourceArray.concat().sort(<span class="function">(<span class="params">a,b</span>) =&gt;</span> a-b); <span class="comment">// 没有对源数组进行直接操作</span></div><div class="line">  <span class="keyword">let</span> pre;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = sortedSourceArray.length; i &lt; len; i++) &#123;</div><div class="line">    <span class="keyword">let</span> current = sortedSourceArray[i];</div><div class="line">    <span class="keyword">if</span> (!i || pre !== current) &#123;</div><div class="line">      targetArray.push(current);</div><div class="line">    &#125;</div><div class="line">    pre = current;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> targetArray;</div><div class="line">&#125;</div><div class="line"><span class="keyword">const</span> sourceArray = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>];</div><div class="line"><span class="built_in">console</span>.log(unique(sourceArray)); <span class="comment">// [1, 2]</span></div></pre></td></tr></table></figure>
<p>这种方式对于大量已经排序的数组效率有很大的提升，但是如果你的数据没有排序，又存在多种数据类型，那还是考虑其它方式会比较好。</p>
<h4 id="3-filter">3、filter</h4>
<p>若是依赖ES5提供的强大原生方法，可以大大的简化我们的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">sourceArray</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> sourceArray.filter(<span class="function">(<span class="params">item, index , arr</span>) =&gt;</span> sourceArray.indexOf(item) === index);</div><div class="line">&#125;</div><div class="line"><span class="keyword">const</span> sourceArray = [<span class="number">1</span>, <span class="string">'2'</span>, <span class="number">1</span>, <span class="string">'1'</span>, <span class="number">1</span>, <span class="number">2</span>];</div><div class="line"><span class="built_in">console</span>.log(unique(sourceArray)); <span class="comment">// [1, '2', '1', 2]</span></div></pre></td></tr></table></figure>
<p>是不是超级简洁了。</p>
<h4 id="4-键值对">4、键值对</h4>
<p>在用键值对判断另外一个值的时候，如果该属性存在，则说明该值是重复的。我们可以利用hasOwnProperty这个方法进行判断。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">sourceArray</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> obj = &#123;&#125;;</div><div class="line">  <span class="keyword">return</span> sourceArray.filter(<span class="function"><span class="keyword">function</span> (<span class="params">item, index, array</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> obj.hasOwnProperty(item) ? <span class="literal">false</span> : (obj[item] = <span class="literal">true</span>)</div><div class="line">  &#125;)</div><div class="line">&#125;</div><div class="line"><span class="keyword">const</span> sourceArray = [<span class="number">1</span>, <span class="string">'2'</span>, <span class="number">1</span>, <span class="string">'1'</span>, <span class="number">1</span>, <span class="number">2</span>];</div><div class="line"><span class="built_in">console</span>.log(unique(sourceArray)); <span class="comment">// [1, '2']</span></div></pre></td></tr></table></figure>
<p>只打印出来了1, '2'，字符串‘2’和数字2在对象里面表示的是同一个属性，我们其实可以用拼接字符串的形式来避免这个问题。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">sourceArray</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> obj = &#123;&#125;;</div><div class="line">  <span class="keyword">return</span> sourceArray.filter(<span class="function"><span class="keyword">function</span> (<span class="params">item, index, array</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> obj.hasOwnProperty(<span class="keyword">typeof</span> item + item) ? <span class="literal">false</span> : (obj[<span class="keyword">typeof</span> item + item] = <span class="literal">true</span>);</div><div class="line">  &#125;)</div><div class="line">&#125;</div><div class="line"><span class="keyword">const</span> sourceArray = [<span class="number">1</span>, <span class="string">'2'</span>, <span class="number">1</span>, <span class="string">'1'</span>, <span class="number">1</span>, <span class="number">2</span>];</div><div class="line"><span class="built_in">console</span>.log(unique(sourceArray)); <span class="comment">// [1, '2', '1', 2]</span></div></pre></td></tr></table></figure>
<p>最后如果遇到item是对象的情况，那么经过typeof item + item后将会是object[object Object]。如果要对象将转化为字符串的形式，我们可以使用JSON.stringify方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">sourceArray</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> obj = &#123;&#125;;</div><div class="line">  <span class="keyword">return</span> sourceArray.filter(<span class="function"><span class="keyword">function</span> (<span class="params">item, index, array</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">typeof</span> item + item);</div><div class="line">    <span class="keyword">return</span> obj.hasOwnProperty(<span class="keyword">typeof</span> item + <span class="built_in">JSON</span>.stringify(item)) ? <span class="literal">false</span> : (obj[<span class="keyword">typeof</span> item + item] = <span class="literal">true</span>);</div><div class="line">  &#125;)</div><div class="line">&#125;</div><div class="line"><span class="keyword">const</span> sourceArray = [<span class="number">1</span>, <span class="string">'2'</span>, <span class="number">1</span>, <span class="string">'1'</span>, <span class="number">1</span>, <span class="number">2</span>];</div><div class="line"><span class="built_in">console</span>.log(unique(sourceArray)); <span class="comment">// [1, '2', '1', 2]</span></div></pre></td></tr></table></figure>
<h4 id="5-es6">5、ES6</h4>
<p>ES6的<strong>Set</strong>对象允许你存储任何类型的唯一值，无论是<a href="https://developer.mozilla.org/en-US/docs/Glossary/Primitive" target="_blank" rel="external">原始值</a>或者是对象引用。我们可以利用这个对象来储存数组的唯一值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> unique = <span class="function"><span class="params">sourceArray</span> =&gt;</span> [...new <span class="built_in">Set</span>(sourceArray)];</div><div class="line"><span class="keyword">const</span> sourceArray = [<span class="number">1</span>, <span class="string">'2'</span>, <span class="number">1</span>, <span class="string">'1'</span>, <span class="number">1</span>, <span class="number">2</span>];</div><div class="line"><span class="built_in">console</span>.log(unique(sourceArray)); <span class="comment">// [1, '2', '1', 2]</span></div></pre></td></tr></table></figure>
<p>JavaScript竟然进化到了如此程度。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在大量的数据处理中，我们经常会使用到数据去重，得到唯一数组，以便展示。下面来看看常用的几种数组去重的方式。&lt;/p&gt;
&lt;h4 id=&quot;1-循环遍历&quot;&gt;1、循环遍历&lt;/h4&gt;
&lt;p&gt;在这种方式中，通过源数组与目标数组进行比较，来判断源数组的元素在目标数组中是否唯一存在。上代码：
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://keminu.com/tags/JavaScript/"/>
    
      <category term="数组" scheme="http://keminu.com/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>精通JavaScript正则之模板引擎</title>
    <link href="http://keminu.com/2018/04/08/%E7%B2%BE%E9%80%9AJavaScript%E6%AD%A3%E5%88%99%E4%B9%8B%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/"/>
    <id>http://keminu.com/2018/04/08/精通JavaScript正则之模板引擎/</id>
    <published>2018-04-08T14:50:08.000Z</published>
    <updated>2018-04-18T13:11:49.292Z</updated>
    
    <content type="html"><![CDATA[<p>在前端的开发中经常会使用到模板引擎，前端渲染中比如前端框架Knockout、Vue和Angular（React的JSX不属于模板，它是一个带语法糖的手写 AST），在解析指令语法时都会使用对应的模板引擎进行解析，而基于Node.js进行渲染的EJS，DoTjs这些，原理也都是类似。</p>
<p>现在我们一步步来，看看它们是怎么实现的。</p>
<p>首先，我想它的使用方式是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> templateEngine = <span class="function">(<span class="params">tpl, data</span>) =&gt;</span> &#123;</div><div class="line">    <span class="comment">// 这里模板引擎实现方式</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">const</span> template = <span class="string">'&lt;p&gt;Hi, my name is &lt;%name%&gt;. My job is &lt;%job%&gt;.&lt;/p&gt;'</span>;</div><div class="line"><span class="built_in">console</span>.log(templateEngine(template, &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">"nuoka"</span>,</div><div class="line">    <span class="attr">job</span>: <span class="string">'write bug'</span></div><div class="line">&#125;));</div></pre></td></tr></table></figure>
<p>当使用templateEngine这个函数，并传入一些参数，我们期待它得到</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Hi, my name is nuoka. My job is write bug.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div></pre></td></tr></table></figure>
<p>第一步我们要得到动态模板，也就是<code>&lt;%name%&gt;</code>这些，然后再用真实的数据去替换它。对于字符串的处理，我们很容易就想到使用正则来处理，关于正则的使用基础，可以看看前面的文章。好了，来写我们的第一个正则表达式，</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> reg = <span class="regexp">/&lt;%([^%&gt;]+)?%&gt;/g</span>;</div></pre></td></tr></table></figure>
<p>通过这个正则，我们可以获取到以<code>&lt;%</code>开头，以<code>%&gt;</code>结尾的片段。用<code>exec</code>执行下，可以得到一个包含匹配结果的数组：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> match = reg.exec(template);</div><div class="line"><span class="built_in">console</span>.log(match);</div><div class="line"><span class="comment">// 得到下面的输出</span></div><div class="line"><span class="comment">// [</span></div><div class="line"><span class="comment">//		"&lt;%name%&gt;"</span></div><div class="line"><span class="comment">//		1: "name"</span></div><div class="line"><span class="comment">//		groups: undefined</span></div><div class="line"><span class="comment">//		index: 18</span></div><div class="line"><span class="comment">//		input: "&lt;p&gt;Hi, my name is &lt;%name%&gt;. My job is &lt;%job%&gt;.&lt;/p&gt;"</span></div><div class="line"><span class="comment">// ]</span></div></pre></td></tr></table></figure>
<p>可以看到返回的数组里只包括一个匹配结果，所以这是我们还需要使用一个<code>while</code>循环来获取全部的结果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> match;</div><div class="line"><span class="keyword">const</span> reg = <span class="regexp">/&lt;%([^%&gt;]+)?%&gt;/g</span>,</div><div class="line">      template = <span class="string">'&lt;p&gt;Hi, my name is &lt;%name%&gt;. My job is &lt;%job%&gt;.&lt;/p&gt;'</span>;</div><div class="line"><span class="keyword">while</span> (match = re.exec(template)) &#123;</div><div class="line">    <span class="built_in">console</span>.log(match);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>好了，现在我们能够获取到所有的模板片段，只需要把数据填充进去就可以了，这里使用replace方法来实现。来看看我们最粗略的模板函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> templateEngine = <span class="function">(<span class="params">tpl, data</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">let</span> reg = <span class="regexp">/&lt;%([^%&gt;]+)?%&gt;/g</span>, </div><div class="line">        match;</div><div class="line">    <span class="keyword">while</span>(match = reg.exec(tpl)) &#123;</div><div class="line">        tpl = tpl.replace(match[<span class="number">0</span>], data[match[<span class="number">1</span>]])</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> tpl;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(templateEngine(template, &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">"nuoka"</span>,</div><div class="line">    <span class="attr">job</span>: <span class="string">'write bug'</span></div><div class="line">&#125;));</div></pre></td></tr></table></figure>
<p>Boom，第一个模板函数实现了，是不是很简单？</p>
<p>这样足够了吗？然而并没有，考虑下面的情况，我们把输入数据变成这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">'nuoka'</span>,</div><div class="line">    <span class="attr">profile</span>: &#123;</div><div class="line">        <span class="attr">job</span>: <span class="string">'write bug'</span>,</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当使用<code>profile.job</code>去填充数据的时候，发现使用不了了，因为并没有找到<code>profile.job</code>这个属性。要如何解决这个问题呢？</p>
<p>要是<code>profile.job</code>是一个语句就好了，这样就可以通过<code>.</code>操作符去获取到job属性。通过这个思路，也容易想到，在JavaScript中要把字符串当作语句来执行，可用的方式有<code>eval</code>和<code>new Function</code>，在这里我们就用<code>new Function</code>来试试。来看一下它的基本使用方式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> fn = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'arg'</span>, <span class="string">'console.log(arg + 1);'</span>);</div><div class="line">fn(<span class="number">1</span>);  <span class="comment">// 输出2</span></div></pre></td></tr></table></figure>
<p>上面的代码等价于：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> fn = <span class="function">(<span class="params">arg</span>) =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(arg + <span class="number">1</span>);</div><div class="line">&#125;;</div><div class="line">fn(<span class="number">1</span>);  <span class="comment">// 输出2</span></div></pre></td></tr></table></figure>
<p>现在，我们可以定义一个函数，它的参数和函数体都来自于字符串，很棒，这正是我们想要的。在创建这个函数之前，我们还需要想想怎么构造出它的函数体？</p>
<p>这个函数体应该返回一个处理好的模板字符串，像是这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">return</span> </div><div class="line"><span class="string">"&lt;p&gt;Hi, my name is "</span> + </div><div class="line"><span class="keyword">this</span>.name + </div><div class="line"><span class="string">"My job is"</span> + </div><div class="line"><span class="keyword">this</span>.profile.job + </div><div class="line"><span class="string">" .&lt;/p&gt;"</span>;</div></pre></td></tr></table></figure>
<p>但是这种方式并不完美，因为如果我们想在模板里嵌套循环的话，这没法做，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> template = </div><div class="line"><span class="string">'My skills:'</span> + </div><div class="line"><span class="string">'&lt;%for(var index in this.skills) &#123;%&gt;'</span> + </div><div class="line"><span class="string">'&lt;a href=""&gt;&lt;%this.skills[index]%&gt;&lt;/a&gt;'</span> +</div><div class="line"><span class="string">'&lt;%&#125;%&gt;'</span>;</div></pre></td></tr></table></figure>
<p>转化为等价函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">return</span></div><div class="line"><span class="string">'My skills:'</span> + </div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> index <span class="keyword">in</span> <span class="keyword">this</span>.skills) &#123; +</div><div class="line"><span class="string">'&lt;a href=""&gt;'</span> + </div><div class="line"><span class="keyword">this</span>.skills[index] +</div><div class="line"><span class="string">'&lt;/a&gt;'</span> +</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>报语法错误了！</p>
<p>怎么办？</p>
<p>最终我们是要返回一个字符串的，但是又想在返回语句里把真实的语法和字符串分开，并且支持for循环，这里可以先把字符串放入数组里，再通过join方法转化为字符串：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> r = [];</div><div class="line">r.push(<span class="string">'My skills:'</span>); </div><div class="line"><span class="keyword">for</span>(<span class="keyword">let</span> index <span class="keyword">in</span> <span class="keyword">this</span>.skills) &#123;</div><div class="line">r.push(<span class="string">'&lt;a href=""&gt;'</span>);</div><div class="line">r.push(<span class="keyword">this</span>.skills[index]);</div><div class="line">r.push(<span class="string">'&lt;/a&gt;'</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> r.join(<span class="string">''</span>);</div></pre></td></tr></table></figure>
<p>下一步，我们来重写我们的模板函数，为了方便在浏览器中测试，我们使用旧的语法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> templateEngine = <span class="function"><span class="keyword">function</span>(<span class="params">tpl, data</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> re = <span class="regexp">/&lt;%([^%&gt;]+)?%&gt;/g</span>,</div><div class="line">        code = <span class="string">'var r=[];\n'</span>,</div><div class="line">        cursor = <span class="number">0</span>, <span class="comment">// 这个用来指示处理到了哪个字符</span></div><div class="line">        match;</div><div class="line">    <span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">line</span>) </span>&#123;</div><div class="line">        <span class="comment">// 替换掉转义字符'"'，并放入数组里</span></div><div class="line">        code += <span class="string">'r.push("'</span> + line.replace(<span class="regexp">/"/g</span>, <span class="string">'\\"'</span>) + <span class="string">'");\n'</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span>(match = re.exec(tpl)) &#123;</div><div class="line">        <span class="comment">// 通过正则把模板和非模板分开</span></div><div class="line">        add(tpl.slice(cursor, match.index));</div><div class="line">        add(match[<span class="number">1</span>]);</div><div class="line">        cursor = match.index + match[<span class="number">0</span>].length;</div><div class="line">    &#125;</div><div class="line">    add(tpl.substr(cursor, tpl.length - cursor));</div><div class="line">    code += <span class="string">'return r.join("");'</span>; <span class="comment">// &lt;-- return the result</span></div><div class="line">    <span class="built_in">console</span>.log(code);</div><div class="line">    <span class="keyword">return</span> tpl;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> template = <span class="string">'&lt;p&gt;Hi, my name is &lt;%this.name%&gt;. My job is &lt;%this.profile.job%&gt;.&lt;/p&gt;'</span>;</div><div class="line"><span class="built_in">console</span>.log(templateEngine(template, &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">"nuoka"</span>,</div><div class="line">    <span class="attr">profile</span>: &#123; <span class="attr">job</span>: <span class="string">'write bug'</span> &#125;</div><div class="line">&#125;));</div></pre></td></tr></table></figure>
<p>这里要注意的是处理双引号那部分，如果不进行转义，那么它将是无效的js语法。运行一下上面的例子，看看它打印出什么来。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> r=[];</div><div class="line">r.push(<span class="string">"&lt;p&gt;Hi, my name is "</span>);</div><div class="line">r.push(<span class="string">"this.name"</span>);</div><div class="line">r.push(<span class="string">". My job is "</span>);</div><div class="line">r.push(<span class="string">"this.profile.job"</span>);</div><div class="line">r.push(<span class="string">"."</span>);</div><div class="line"><span class="keyword">return</span> r.join(<span class="string">""</span>);</div></pre></td></tr></table></figure>
<p>出了点意外，<em>this.name</em>和<em>this.profile.job</em>不是我们想要的，它们不应该被双引号包裹着。来修改一下add方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">line, js</span>) </span>&#123;</div><div class="line">    js ? code += <span class="string">'r.push('</span> + line + <span class="string">');\n'</span> </div><div class="line">       : code += <span class="string">'r.push("'</span> + line.replace(<span class="regexp">/"/g</span>, <span class="string">'\\"'</span>) + <span class="string">'");\n'</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> match;</div><div class="line"><span class="keyword">while</span>(match = re.exec(tpl)) &#123;</div><div class="line">    add(tpl.slice(cursor, match.index));</div><div class="line">    add(match[<span class="number">1</span>], <span class="literal">true</span>); <span class="comment">// 匹配的字符应该是有效的js语法</span></div><div class="line">    cursor = match.index + match[<span class="number">0</span>].length;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后生成了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> r=[];</div><div class="line">r.push(<span class="string">"&lt;p&gt;Hi, my name is "</span>);</div><div class="line">r.push(<span class="keyword">this</span>.name);</div><div class="line">r.push(<span class="string">". My job is "</span>);</div><div class="line">r.push(<span class="keyword">this</span>.profile.job);</div><div class="line">r.push(<span class="string">"."</span>);</div><div class="line"><span class="keyword">return</span> r.join(<span class="string">""</span>);</div></pre></td></tr></table></figure>
<p>在templateEngine函数的最后，就可以执行生成的函数体了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Function</span>(code.replace(<span class="regexp">/[\r\t\n]/g</span>, <span class="string">''</span>)).apply(data);</div></pre></td></tr></table></figure>
<p>我们使用apply方法来调用这个函数，它生成一个函数作用域，这样里面this就自动指向了data。</p>
<p>到现在我们已经做得非常好了，能够支持基本的js语法，分离出模板，最后我们还想支持更多的js语法，比如说<em>if/else</em>、<em>for</em>循环。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> template = </div><div class="line"><span class="string">'My skills:'</span> + </div><div class="line"><span class="string">'&lt;%for(var index in this.skills) &#123;%&gt;'</span> + </div><div class="line"><span class="string">'&lt;a href="#"&gt;&lt;%this.skills[index]%&gt;&lt;/a&gt;'</span> +</div><div class="line"><span class="string">'&lt;%&#125;%&gt;'</span>;</div><div class="line"><span class="built_in">console</span>.log(templateEngine(template, &#123;</div><div class="line">    <span class="attr">skills</span>: [<span class="string">"js"</span>, <span class="string">"html"</span>, <span class="string">"css"</span>]</div><div class="line">&#125;));</div></pre></td></tr></table></figure>
<p>对于上面的模板就会抛出一个<em>Uncaught SyntaxError. Unexpected token for</em>语法错误。我们调试一下，在控制台上就会看到错误所在：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> r=[];</div><div class="line">r.push(<span class="string">"My skills:"</span>);</div><div class="line">r.push(<span class="keyword">for</span>(<span class="keyword">var</span> index <span class="keyword">in</span> <span class="keyword">this</span>.skills) &#123;);</div><div class="line">r.push(<span class="string">"&lt;a href=\"\"&gt;"</span>);</div><div class="line">r.push(<span class="keyword">this</span>.skills[index]);</div><div class="line">r.push(<span class="string">"&lt;/a&gt;"</span>);</div><div class="line">r.push(&#125;);</div><div class="line">r.push(<span class="string">""</span>);</div><div class="line"><span class="keyword">return</span> r.join(<span class="string">""</span>);</div></pre></td></tr></table></figure>
<p><em>for</em>循环不应该放入数组里面，我们再添加一个正则表达式，把<strong>if, <em>for</em>, <em>else</em>, <em>switch</em>, <em>case</em>, <em>break</em>, { 或者 }</strong> 开头的单独的放在一行，</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> re = <span class="regexp">/&lt;%([^%&gt;]+)?%&gt;/g</span>,</div><div class="line">    reExp = <span class="regexp">/(^( )?(if|for|else|switch|case|break|&#123;|&#125;))(.*)?/g</span>,  <span class="comment">// 新增处理更多语法</span></div><div class="line">    code = <span class="string">'var r=[];\n'</span>,</div><div class="line">    cursor = <span class="number">0</span>;</div><div class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">line, js</span>) </span>&#123;</div><div class="line">    js ? code += line.match(reExp) </div><div class="line">       ? line + <span class="string">'\n'</span> </div><div class="line">       : <span class="string">'r.push('</span> + line + <span class="string">');\n'</span> </div><div class="line">       : code += <span class="string">'r.push("'</span> + line.replace(<span class="regexp">/"/g</span>, <span class="string">'\\"'</span>) + <span class="string">'");\n'</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>增加一个正则处理后的结果像这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> r=[];</div><div class="line">r.push(<span class="string">"My skills:"</span>);</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> index <span class="keyword">in</span> <span class="keyword">this</span>.skills) &#123;</div><div class="line">r.push(<span class="string">"&lt;a href=\"#\"&gt;"</span>);</div><div class="line">r.push(<span class="keyword">this</span>.skills[index]);</div><div class="line">r.push(<span class="string">"&lt;/a&gt;"</span>);</div><div class="line">&#125;</div><div class="line">r.push(<span class="string">""</span>);</div><div class="line"><span class="keyword">return</span> r.join(<span class="string">""</span>);</div></pre></td></tr></table></figure>
<p>模板渲染后就是这样啦：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">My skills:<span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>js<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>html<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>css<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></div></pre></td></tr></table></figure>
<p>当然我们还可以使用更多复杂的表达式了，比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> template = </div><div class="line"><span class="string">'My skills:'</span> + </div><div class="line"><span class="string">'&lt;%if(this.showSkills) &#123;%&gt;'</span> +</div><div class="line">    <span class="string">'&lt;%for(var index in this.skills) &#123;%&gt;'</span> + </div><div class="line">    <span class="string">'&lt;a href="#"&gt;&lt;%this.skills[index]%&gt;&lt;/a&gt;'</span> +</div><div class="line">    <span class="string">'&lt;%&#125;%&gt;'</span> +</div><div class="line"><span class="string">'&lt;%&#125; else &#123;%&gt;'</span> +</div><div class="line">    <span class="string">'&lt;p&gt;none&lt;/p&gt;'</span> +</div><div class="line"><span class="string">'&lt;%&#125;%&gt;'</span>;</div><div class="line"><span class="built_in">console</span>.log(templateEngine(template, &#123;</div><div class="line">    <span class="attr">skills</span>: [<span class="string">"js"</span>, <span class="string">"html"</span>, <span class="string">"css"</span>],</div><div class="line">    <span class="attr">showSkills</span>: <span class="literal">true</span></div><div class="line">&#125;));</div></pre></td></tr></table></figure>
<p>现在再把代码稍微整理下，得到一个最终版本的模板处理函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> templateEngine = <span class="function"><span class="keyword">function</span>(<span class="params">html, options</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> re     = <span class="regexp">/&lt;%([^%&gt;]+)?%&gt;/g</span>, </div><div class="line">        reExp  = <span class="regexp">/(^( )?(if|for|else|switch|case|break|&#123;|&#125;))(.*)?/g</span>, </div><div class="line">        code   = <span class="string">'var r=[];\n'</span>, </div><div class="line">        cursor = <span class="number">0</span>, </div><div class="line">        match;</div><div class="line">    <span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">line, js</span>) </span>&#123;</div><div class="line">        js ? (code += line.match(reExp) </div><div class="line">           ? line + <span class="string">'\n'</span> </div><div class="line">           : <span class="string">'r.push('</span> + line + <span class="string">');\n'</span>) </div><div class="line">           : (code += line != <span class="string">''</span> ? <span class="string">'r.push("'</span> + line.replace(<span class="regexp">/"/g</span>, <span class="string">'\\"'</span>) + <span class="string">'");\n'</span> : <span class="string">''</span>);</div><div class="line">        <span class="keyword">return</span> add;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span>(match = re.exec(html)) &#123;</div><div class="line">        add(html.slice(cursor, match.index))(match[<span class="number">1</span>], <span class="literal">true</span>);</div><div class="line">        cursor = match.index + match[<span class="number">0</span>].length;</div><div class="line">    &#125;</div><div class="line">    add(html.substr(cursor, html.length - cursor));</div><div class="line">    code += <span class="string">'return r.join("");'</span>;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Function</span>(code.replace(<span class="regexp">/[\r\t\n]/g</span>, <span class="string">''</span>)).apply(options);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>参考资料：</p>
<p>1、https://github.com/krasimir/absurd/blob/master/lib/processors/html/helpers/TemplateEngine.js</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在前端的开发中经常会使用到模板引擎，前端渲染中比如前端框架Knockout、Vue和Angular（React的JSX不属于模板，它是一个带语法糖的手写 AST），在解析指令语法时都会使用对应的模板引擎进行解析，而基于Node.js进行渲染的EJS，DoTjs这些，原理也都
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://keminu.com/tags/JavaScript/"/>
    
      <category term="正则表达式" scheme="http://keminu.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
      <category term="模板引擎" scheme="http://keminu.com/tags/%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>理解JavaScript之数组扁平化</title>
    <link href="http://keminu.com/2018/03/06/%E7%90%86%E8%A7%A3JavaScript%E4%B9%8B%E6%95%B0%E7%BB%84%E6%89%81%E5%B9%B3%E5%8C%96/"/>
    <id>http://keminu.com/2018/03/06/理解JavaScript之数组扁平化/</id>
    <published>2018-03-06T03:12:57.000Z</published>
    <updated>2018-03-07T00:28:49.061Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是数组扁平化">什么是数组扁平化</h3>
<p>就是将多维数组转化为一维数组，并且不能改变原来数组的值。比如说原来的数组是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]];</div></pre></td></tr></table></figure>
<p>那么扁平化之后就是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</div></pre></td></tr></table></figure>
<p>那么我们实现数组扁平化有什么用呢？可以用它来求几个数组的并集，也可以用它来找出差集。</p>
<h3 id="如何实现">如何实现</h3>
<p>下面看看实现的方式。第一种很容易想到的是循环数组元素，如果还是一个数组，就递归调用该方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 方法 1</span></div><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> result = [];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = arr.length; i &lt; len; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(arr[i])) &#123;</div><div class="line">            result = result.concat(flatten(arr[i]))</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            result.push(arr[i])</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(flatten(arr))</div></pre></td></tr></table></figure>
<p>这是一个简单的实现，并没有做什么优化。</p>
<p>我们知道<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/toString" target="_blank" rel="external">Array.prototype.toString</a>可以返回一个字符串，表示指定的数组及其元素。对于数组对象，<code>toString</code> 方法返回一个字符串，该字符串由数组中的每个元素的 <code>toString()</code> 返回值经调用 <code>join()</code> 方法连接（由逗号隔开）组成。而<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/split" target="_blank" rel="external">String.prototype.split</a>方法使用指定的分隔符字符串将一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/String" target="_blank" rel="external"><code>String</code></a>对象分割成字符串数组，以将字符串分隔为子字符串，以确定每个拆分的位置。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 方法2</span></div><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> arr.toString().split(<span class="string">','</span>).map(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> +item</div><div class="line">    &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(flatten(arr))</div></pre></td></tr></table></figure>
<p>对于数组里面含有不同类型的数据时，这种方式就不适用了。</p>
<p>既然是对数组进行处理，最终返回一个值，我们就可以考虑使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce" target="_blank" rel="external">Array.prototype.reduce</a> 来简化代码，这个方法对累加器和数组中的每个元素（从左到右）应用一个函数，将其减少为单个值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 方法3</span></div><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> arr.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">prev, next</span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> prev.concat(<span class="built_in">Array</span>.isArray(next) ? flatten(next) : next)</div><div class="line">    &#125;, [])</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(flatten(arr))</div></pre></td></tr></table></figure>
<p>ES6 增加了扩展运算符，用于取出参数对象的所有可遍历属性，拷贝到当前对象之中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]];</div><div class="line"><span class="built_in">console</span>.log([].concat(...arr)); <span class="comment">// [1, 2, [3, 4]]</span></div></pre></td></tr></table></figure>
<p>这种方法只可以扁平一层，但是可以稍微改改：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 方法4</span></div><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (arr.some(<span class="function"><span class="params">item</span> =&gt;</span> <span class="built_in">Array</span>.isArray(item))) &#123;</div><div class="line">        arr = [].concat(...arr);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> arr;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(flatten(arr))</div></pre></td></tr></table></figure>
<p>最后放出终极大招，看看underscore是怎么实现的？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 数组扁平化</div><div class="line"> * @param  &#123;Array&#125; input   要处理的数组</div><div class="line"> * @param  &#123;boolean&#125; shallow 是否只扁平一层</div><div class="line"> * @param  &#123;boolean&#125; strict  是否严格处理元素，下面有解释</div><div class="line"> * @param  &#123;Array&#125; output  这是为了方便递归而传递的参数</div><div class="line"> * 源码地址：https://github.com/jashkenas/underscore/blob/master/underscore.js#L528</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">input, shallow, strict, output</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 递归使用的时候会用到output</span></div><div class="line">    output = output || [];</div><div class="line">    <span class="keyword">var</span> idx = output.length;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = input.length; i &lt; len; i++) &#123;</div><div class="line"></div><div class="line">        <span class="keyword">var</span> value = input[i];</div><div class="line">        <span class="comment">// 如果是数组，就进行处理</span></div><div class="line">        <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</div><div class="line">            <span class="comment">// 如果是只扁平一层，遍历该数组，依此填入 output</span></div><div class="line">            <span class="keyword">if</span> (shallow) &#123;</div><div class="line">                <span class="keyword">var</span> j = <span class="number">0</span>, len = value.length;</div><div class="line">                <span class="keyword">while</span> (j &lt; len) output[idx++] = value[j++];</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 如果是全部扁平就递归，传入已经处理的 output，递归中接着处理 output</span></div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                flatten(value, shallow, strict, output);</div><div class="line">                idx = output.length;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 不是数组，根据 strict 的值判断是跳过不处理还是放入 output</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!strict)&#123;</div><div class="line">            output[idx++] = value;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> output;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>来看看主要的参数解释：</p>
<ul>
<li>shallow true + strict false ：正常扁平一层</li>
<li>shallow false + strict false ：正常扁平所有层</li>
<li>shallow true + strict true ：去掉非数组元素</li>
<li>shallow false + strict true ： 返回一个[]</li>
</ul>
<p>Underscore确实有非常多值得学习的地方，更推荐Lodash。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;什么是数组扁平化&quot;&gt;什么是数组扁平化&lt;/h3&gt;
&lt;p&gt;就是将多维数组转化为一维数组，并且不能改变原来数组的值。比如说原来的数组是：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gut
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://keminu.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>vue项目性能优化</title>
    <link href="http://keminu.com/2018/02/04/vue%E9%A1%B9%E7%9B%AE%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>http://keminu.com/2018/02/04/vue项目性能优化/</id>
    <published>2018-02-04T12:31:11.000Z</published>
    <updated>2018-02-06T16:20:35.408Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章主要是对之前项目的一点总结，提出一些在开发中可以进行性能优化的点，针对vue-cli初始化或webpack打包的项目。如果需要了解web性能方面的知识，请参考<a href="https://maizsss.github.io/2017/12/12/Web%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" target="_blank" rel="external">web性能</a>。</p>
<h3 id="代码分割">代码分割</h3>
<p>默认的情况下，webpack会把你应用的代码打包到一个bundle中，如果你的项目有很多的页面，这样打包出来的文件会非常大，导致加载慢。最好的方式是按照页面划分，每个页面单独分割出一个文件，然后按需加载。比如，你的页面中有一个首页和一个用户信息页，那么可以把它们分成两个文件index.vue和info.vue。当然，如果首页还是很大，还可以按照页面组件来划分，比如menu.vue、tab.vue、modal.vue等。</p>
<h3 id="组件动态加载">组件动态加载</h3>
<p>通过上面的分割代码之后，bundle被分成了很多小部分，这样我们可以动态加载需要的部分。来看看是怎么实现的？</p>
<p>利用import()作为动态模块加载器。在webpack中已经把import()作为一个代码分割点，它把import来的模块打包成一个单独的文件，并在需要的时候去加载。import接收一个文件路径作为参数，然后返回一个Promise。这里有一个异步单文件组件：</p>
<p>AsyncComponent.vue</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;template&gt;</div><div class="line">  &lt;div&gt;Async Component&lt;/div&gt;</div><div class="line">&lt;/template&gt;</div><div class="line">&lt;script&gt;</div><div class="line">  export default &#123; &#125;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>使用import就像这样如此简单整洁的完成异步加载：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">new Vue(&#123; </div><div class="line">  el: &apos;#app&apos;,</div><div class="line">  components: &#123;</div><div class="line">    AsyncComponent: () =&gt; import(&apos;./AsyncComponent.vue&apos;)</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="vue-router路由懒加载">vue-router路由懒加载</h3>
<p>在vue的项目中，经常会使用vue-router去管理SPA应用。当页面非常多时，打包的文件会变得很大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了。使用import，再结合webpack，很容易就能做到。</p>
<p>首先，定义一个能够被 Webpack 自动代码分割的异步组件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">const AsyncComponent = () =&gt; import(&apos;./AsyncComponent.vue&apos;)</div></pre></td></tr></table></figure>
<p>然后在路由定义中去引用它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">const router = new VueRouter(&#123;</div><div class="line">  routes: [</div><div class="line">    &#123; path: &apos;/asyncComponent&apos;, component: AsyncComponent &#125;</div><div class="line">  ]</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>当然，如果你想对你的组件使用不同的名字，也很容易做到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">const asyncComponent = () =&gt; import(/* webpackChunkName: &quot;async-component&quot; */ &apos;./asyncComponent.vue&apos;)</div></pre></td></tr></table></figure>
<p>这样打包出来的分块名就是async-component.[hash].js。</p>
<h3 id="运行时构建">运行时构建</h3>
<p>如果在应用中你只使用了渲染函数(render functions)（在单文件组件中，会把组件编译成render function），而不需要html 模板(templates)，那么其实你不需要vue的模板编译器，这样在webpack打包的时候大约会减少25%的体积。当使用<em>import vue from 'vue</em>'时，默认使用运行时构建，你也可以改变webpack的配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">resolve: &#123;</div><div class="line">  alias: &#123;</div><div class="line">    &apos;vue$&apos;: &apos;vue/dist/vue.esm.js&apos; // Use the full build</div><div class="line">  &#125;</div><div class="line">&#125;,</div></pre></td></tr></table></figure>
<h3 id="在生产环境中去掉warnings-and-error信息">在生产环境中去掉warnings and error信息</h3>
<p>把<em>process.env.NODE_ENV</em>设置成<em>production</em>，就可以去掉这些不需要的信息代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">if (process.env.NODE_ENV === &apos;production&apos;) &#123;</div><div class="line">  module.exports.plugins = (module.exports.plugins || []).concat([</div><div class="line">    new webpack.DefinePlugin(&#123;</div><div class="line">      &apos;process.env&apos;: &#123;</div><div class="line">        NODE_ENV: &apos;&quot;production&quot;&apos;</div><div class="line">      &#125;</div><div class="line">    &#125;),</div><div class="line">    new webpack.optimize.UglifyJsPlugin()</div><div class="line">  ])</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="cdn化">CDN化</h3>
<p>如果使用vue-cli，配置CDN路径很简单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">module.exports = &#123;</div><div class="line">  build: &#123;</div><div class="line">    assetsSubDirectory: &apos;static&apos;,</div><div class="line">    assetsPublicPath: &apos;./&apos;,  // 这里换成CDN地址</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>这样对于打包后的js和css路径引用是没有问题的，但是js里使用绝对路径或相对路径引用的图片却没有正常引用CDN地址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">export default &#123;</div><div class="line">    data() &#123;</div><div class="line">        return &#123;</div><div class="line">            img: &apos;./logo.png&apos;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里换一种方式就能正确引用了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">import logo from &apos;./logo.png&apos;</div><div class="line"></div><div class="line">export default &#123;</div><div class="line">    data() &#123;</div><div class="line">        return &#123;</div><div class="line">            img: logo</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="代码层面">代码层面</h3>
<p>v-show or v-if：如果不是频繁的切换显示，我更倾向于使用v-if，它可以减少页面中dom总数，并且它的切换时间肉眼基本没有什么感觉的。</p>
<h3 id="参考资料">参考资料</h3>
<p>1、<a href="https://segmentfault.com/a/1190000009443366" target="_blank" rel="external">潜谈vue项目优化</a></p>
<p>2、<a href="https://router.vuejs.org/zh-cn/advanced/lazy-loading.html" target="_blank" rel="external">vue路由懒加载</a></p>
<p>3、<a href="https://vuejsdevelopers.com/2017/07/03/vue-js-code-splitting-webpack/" target="_blank" rel="external">vue-js-code-splitting-webpack</a></p>
<p>4、<a href="https://vuejsdevelopers.com/2017/06/18/vue-js-boost-your-app-with-webpack/" target="_blank" rel="external">vue-js-boost-your-app-with-webpack</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章主要是对之前项目的一点总结，提出一些在开发中可以进行性能优化的点，针对vue-cli初始化或webpack打包的项目。如果需要了解web性能方面的知识，请参考&lt;a href=&quot;https://maizsss.github.io/2017/12/12/Web%E6%8
    
    </summary>
    
    
      <category term="vue" scheme="http://keminu.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>理解JavaScript之值类型与引用类型</title>
    <link href="http://keminu.com/2018/01/02/%E7%90%86%E8%A7%A3JavaScript%E4%B9%8B%E5%80%BC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/"/>
    <id>http://keminu.com/2018/01/02/理解JavaScript之值类型与引用类型/</id>
    <published>2018-01-02T12:57:23.000Z</published>
    <updated>2018-01-06T16:15:13.447Z</updated>
    
    <content type="html"><![CDATA[<p>先来看下面的例子输出什么？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">args</span>) </span>&#123;</div><div class="line">  args.push(<span class="number">4</span>);</div><div class="line">  <span class="built_in">console</span>.log(args); <span class="comment">// 1、输出？</span></div><div class="line">  args = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</div><div class="line">  args.push(<span class="number">7</span>);</div><div class="line">  <span class="built_in">console</span>.log(args); <span class="comment">// 2、输出？</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line">foo(arr);</div><div class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// 3、输出？</span></div></pre></td></tr></table></figure>
<p>1处输出[1, 2, 3, 4]；2处输出[4, 5, 6, 7]；3处输出[1, 2, 3, 4]，为什么不是[4, 5, 6, 7]？</p>
<p>我们知道在最新的ECMAScript标准中定义了7种数据类型，其中，</p>
<p>6种原始类型：Boolean，Null，Undefined，Number，String，Symbol（ECMAScript 6新定义）；</p>
<p>和Object。</p>
<p><strong>而Javascript対值的引用和赋值或者传递完全由值的类型来决定。</strong></p>
<p>对于简单值，总是通过值复制的方式来赋值或传递，包括null、undefined、字符串、数字、布尔以及ES6中的symbol；对于复合值总是通过引用复制的方式赋值或传递，包括对象（数组或封装的对象）、函数。</p>
<p>我们再来看上面的例子，变量arr是数组，属于复合值类型，它的赋值和传递都是通过引用的方式，来看看执行foo函数的时候发生了什么。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">foo(arr);</div><div class="line"><span class="comment">// 对上面函数的执行做一个等价转换</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">args</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> args = arr; <span class="comment">// 创建变量args指向arr指向的值</span></div><div class="line">  args.push(<span class="number">4</span>); <span class="comment">// args和arr是分别指向同一个复合值[1, 2, 3]的两个不同引用。注意，args和arr仅仅是指向值[1, 2, 3]，并非持有，所以调用.push(4)的时候，它们更改的是同一个值，然后它们都指向更改后的新值[1, 2, 3, 4]。</span></div><div class="line">  <span class="built_in">console</span>.log(args); <span class="comment">// [1, 2, 3, 4]</span></div><div class="line">  args = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]; <span class="comment">// 对args重新赋值，相当于重新改变了args的指向，当是并不影响arr原来的指向，也就是说arr还是指向[1, 2, 3, 4]</span></div><div class="line">  args.push(<span class="number">7</span>); <span class="comment">// args = [4, 5, 6, 7]</span></div><div class="line">&#125;</div><div class="line"><span class="comment">// 执行完foo函数后，arr的值为[1, 2, 3, 4]</span></div></pre></td></tr></table></figure>
<p>从这个例子中我们可以得出：</p>
<ul>
<li>运算符<code>=</code>就是<strong>创建或修改</strong>变量在内存中的指向。</li>
<li>初始化变量时为创建，重新赋值即为修改。</li>
<li>我们无法自行决定使用值复制还是引用复制，一切由值的类型来决定。</li>
</ul>
<p>下面我们再尝试从内存占用的角度来解释。</p>
<p>首先看一个简单的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o1 = &#123; <span class="attr">m</span>: <span class="number">1</span> &#125;; <span class="comment">// a1 = &#123; m: 1 &#125;</span></div><div class="line"><span class="keyword">var</span> o2 = o1; <span class="comment">// o2 = &#123; m: 1&#125;</span></div><div class="line">o1 = <span class="number">2</span>; <span class="comment">// 对o1重新赋值</span></div><div class="line"><span class="built_in">console</span>.log(o2); <span class="comment">// &#123; m: 1 &#125;</span></div></pre></td></tr></table></figure>
<p>前两句代码的内存区情况如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">栈</th>
<th style="text-align:center">堆</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">o1, o2</td>
<td style="text-align:center">[[Object]] (指向对象m,m为1)</td>
</tr>
</tbody>
</table>
<p>接下来：</p>
<ol>
<li>创建变量o1指向<strong>对象{m: 1}</strong>;</li>
<li>创建变量o2指向<strong>对象{m: 1}</strong>;</li>
<li>修改o1重新指向<strong>常量2</strong>;</li>
</ol>
<p>现在再来看看内存区情况：</p>
<table>
<thead>
<tr>
<th style="text-align:center">栈</th>
<th style="text-align:center">堆</th>
<th style="text-align:center">常量区</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">o1</td>
<td style="text-align:center"></td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">o2</td>
<td style="text-align:center">[[Object]] (指向对象m,m为1)</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<p>所以o2从头到尾都是指向<strong>对象{m: 1}</strong>。</p>
<p>修改上面一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o1 = &#123; <span class="attr">m</span>: <span class="number">1</span> &#125;; <span class="comment">// a1 = &#123; m: 1 &#125;</span></div><div class="line"><span class="keyword">var</span> o2 = o1; <span class="comment">// o2 = &#123; m: 1&#125;</span></div><div class="line">o1.m = <span class="number">2</span>; <span class="comment">// 对o1重新赋值</span></div><div class="line"><span class="built_in">console</span>.log(o2); <span class="comment">// &#123; m: 2 &#125;</span></div></pre></td></tr></table></figure>
<p>前两句代码执行完o1, o2, m在内存中的分布：</p>
<table>
<thead>
<tr>
<th style="text-align:center">栈</th>
<th style="text-align:center">堆</th>
<th style="text-align:center">常量区</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">o1, o2</td>
<td style="text-align:center">[[Object]] (指向对象m,m为1)</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">m</td>
<td style="text-align:center"></td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
<p>执行完<strong>o1.m = 2</strong>后：</p>
<table>
<thead>
<tr>
<th style="text-align:center">栈</th>
<th style="text-align:center">堆</th>
<th style="text-align:center">常量</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">o1, o2</td>
<td style="text-align:center">[[Object]] (指向对象m,m为2)</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">m</td>
<td style="text-align:center"></td>
<td style="text-align:center">2</td>
</tr>
</tbody>
</table>
<p>执行<strong>o1.m = 2</strong>，相当于通过o1的间接引用改变了m的值，那么所有原来指向m的引用的值都改变了，在这里就是o2所引用的值也改变了。o1和o2从始至终都未改变过其引用，只是m改变了。</p>
<p>根据上面的理论知识，就会想到工作中为了分离变量间的引用所用的操作：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 1、JSON.parse(JSON.stringfify(&#123; a: 0 &#125;)); </span></div><div class="line"><span class="comment">// 2、arr.slice()、arr.concat()</span></div><div class="line"><span class="comment">// 3、_.cloneDeep()</span></div><div class="line"><span class="comment">// 4、解构赋值</span></div></pre></td></tr></table></figure>
<p>总结：</p>
<p>简单标量基本类型值(字符串和数字等)通过值复制来赋值 / 传递，而复合值(对象等)通过引用复制来赋值 / 传递。</p>
<p>JavaScript 中的引用和其他语言中的引用 / 指针不同，它们不能指向别的变量 / 引用，只能指向值。</p>
<p>​			
​		
​</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;先来看下面的例子输出什么？&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/d
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://keminu.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>vue单页应用中设置网页标题</title>
    <link href="http://keminu.com/2017/12/06/vue%E5%8D%95%E9%A1%B5%E5%BA%94%E7%94%A8%E4%B8%AD%E8%AE%BE%E7%BD%AE%E7%BD%91%E9%A1%B5%E6%A0%87%E9%A2%98/"/>
    <id>http://keminu.com/2017/12/06/vue单页应用中设置网页标题/</id>
    <published>2017-12-06T14:52:19.000Z</published>
    <updated>2017-12-07T13:48:05.080Z</updated>
    
    <content type="html"><![CDATA[<!-- toc -->
<!-- tocstop -->
<p>在vue-router的单页应用中，你可能需要在不同的路由设置不同的网页标题，如果你在单文件组件里直接使用document.title来设置页面标题，是不生效的。像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mounted() &#123;</div><div class="line">    document.titile = &apos;title&apos;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样是不生效的。</p>
<p>这里有两种方式可以做到这样的功能。一是在路由里定义对应的组件标题，然后在路由钩子里动态设置，但是这种方式在iOS app下不能被支持，因为它不允许动态改变网页标题。二是通过vue指令，在路由切换完成后，静默加载一个空的iframe来设置title。</p>
<p>第一种方式实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">router.beforeEach((to, from, next) =&gt; &#123;</div><div class="line">  document.title = to.extra.title;</div><div class="line">  next();</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>对应部分路由定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">const routers = [&#123;</div><div class="line">    path: &apos;/&apos;,</div><div class="line">    extra: &#123;</div><div class="line">        title: &apos;首页&apos;</div><div class="line">    &#125;</div><div class="line">&#125;]</div></pre></td></tr></table></figure>
<p>第二种方式实现：</p>
<p>先定义一个函数用来动态修改标题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">export const setMetaTitle = title =&gt; &#123;</div><div class="line">  document.title = title;</div><div class="line">  const mobile = navigator.userAgent.toLowerCase();</div><div class="line">  if (/iphone|ipad|ipod/.test(mobile)) &#123;</div><div class="line">    let iframe = document.createElement(&apos;iframe&apos;);</div><div class="line">    iframe.style.visibility = &apos;hidden&apos;;</div><div class="line">    iframe.setAttribute(&apos;src&apos;, &apos;https://www.baidu.com/&apos;);</div><div class="line">    const iframeCallback = () =&gt; &#123;</div><div class="line">      setTimeout(() =&gt; &#123;</div><div class="line">        iframe.removeEventListener(&apos;load&apos;, iframeCallback);</div><div class="line">        document.body.removeChild(iframe);</div><div class="line">      &#125;, 0);</div><div class="line">    &#125;</div><div class="line">    iframe.addEventListener(&apos;load&apos;, iframeCallback);</div><div class="line">    document.body.appendChild(iframe);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>再在vue的入口点比如app.js里，定义一个vue指令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">import &#123; setMetaTitle &#125; from &apos;@/common/utils&apos;; </div><div class="line"></div><div class="line">Vue.directive(&apos;title&apos;, &#123;</div><div class="line">  inserted(el, binding) &#123;</div><div class="line">    setMetaTitle(binding.value);</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>最后在你的组件里添加这个指令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;template&gt;</div><div class="line">    &lt;div v-title=&quot;这里是你的标题&quot;&gt;&lt;/div&gt;</div><div class="line">&lt;/template&gt;</div><div class="line">&lt;script&gt;</div><div class="line">    export default &#123;&#125;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>推荐第二种方式实现，没毛病。</p>
]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
&lt;!-- tocstop --&gt;
&lt;p&gt;在vue-router的单页应用中，你可能需要在不同的路由设置不同的网页标题，如果你在单文件组件里直接使用document.title来设置页面标题，是不生效的。像这样：&lt;/p&gt;
&lt;figure class=&quot;hi
    
    </summary>
    
    
      <category term="vue" scheme="http://keminu.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>精通JavaScript正则之正则原理</title>
    <link href="http://keminu.com/2017/12/03/%E7%B2%BE%E9%80%9AJavaScript%E6%AD%A3%E5%88%99%E4%B9%8B%E6%AD%A3%E5%88%99%E5%8E%9F%E7%90%86/"/>
    <id>http://keminu.com/2017/12/03/精通JavaScript正则之正则原理/</id>
    <published>2017-12-03T07:10:02.000Z</published>
    <updated>2017-12-06T14:26:23.809Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-为什么要知道些正则匹配原理">1、为什么要知道些正则匹配原理</h3>
<p>知其然，知其所以然。</p>
<h3 id="2-正则匹配引擎">2、正则匹配引擎</h3>
<p>正则引擎大体上可分为不同的两类：DFA和NFA。DFA(Deterministic finite automaton) 确定型有穷自动机，NFA (Non-deterministic finite automaton)　非确定型有穷自动机。</p>
<h4 id="21-nfa">2.1 NFA</h4>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">传统的NFA引擎：运行匹配回溯算法——以指定顺序测试正则表达式的所有可能的扩展并接受第一个匹配项。因为传统的 NFA 构造正则表达式的特定扩展以获得成功的匹配，所以它可以捕获子表达式匹配和匹配的反向引用。但传统 NFA的 回溯使它可以访问完全相同的状态多次（如果通过不同的路径到达该状态）。因此，在最坏情况下，它的执行速度可能非常慢。因为传统的 NFA 接受它找到的第一个匹配，所以它还可能会导致其他（可能更长）匹配未被发现。</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">POSIX NFA 引擎：与传统 NFA 引擎类似，不同点：在可以确保已找到了可能的最长的匹配之前，它们将继续回溯（更慢）；并且在使用 POSIX NFA 时，您恐怕不会愿意在更改回溯搜索的顺序的情况下来支持较短的匹配搜索，而非较长的匹配搜索。</div></pre></td></tr></table></figure>
<h4 id="22-dfa">2.2 DFA</h4>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">DFA引擎：在线性时状态下执行，不要求回溯（因此永远不测试相同的字符两次）；确保匹配最长的可能的字符串；因为只包含有限的状态（？），所以它不能匹配具有反向引用的模式；并且因为它不构造显示扩展，所以它不可以捕获子表达式。</div></pre></td></tr></table></figure>
<p>例：</p>
<p>字符串：<strong>this is yansen’s dog</strong></p>
<p>正则表达式：<strong>/ya(msen|nsen|nsem)/</strong></p>
<p>NFA工作方式：先在字符串中查找y，然后匹配其后是否为a； 如果是a则继续查找其后是否为m；如果不是则匹配其后是否为n(此时淘汰msen支分支)； 然后继续看其后是否依次为s,e；接着测试是否为n，是n则匹配成功，不是则测试是否为m。为什么是 m ？因为 NFA 工作方式是以正则表达式为标准，反复测试字符串，这样同样一个字符串有可能被反复测试了很多次！</p>
<p>DFA工作方式：从<strong>this</strong>中<strong>t</strong>开始依次查找<strong>y</strong>，定位到<strong>y</strong>，已知其后为<strong>a</strong>，则查看表达式是否有<strong>a</strong>，此处正好有<strong>a；<strong>然后字符串</strong>a</strong>后为<strong>n</strong>，DFA依次测试表达式，此时<strong>msen</strong>不符合要求淘汰。<strong>nsen</strong>和<strong>nsem</strong>符合要求，然后DFA依次检查字符串，检测到<strong>sen</strong>中的<strong>n</strong>时只有<strong>nsen</strong>分支符合，则匹配成功！</p>
<h3 id="3-基础知识">3、基础知识</h3>
<h4 id="31-字符串组成">3.1 字符串组成</h4>
<p>对于字符串“<strong>reg</strong>”而言，包括三个字符和四个位置，位置0在<strong>r</strong>前面，位置4在<strong>g</strong>后面。</p>
<h4 id="32-占有字符和零宽度">3.2 占有字符和零宽度</h4>
<p>正则表达式匹配过程中，如果子表达式匹配到的是字符内容，而非位置，并被保存到最终的匹配结果中，那么就认为这个子表达式是占有字符的；如果子表达式匹配的仅仅是位置，或者匹配的内容并不保存到最终的匹配结果中，那么就认为这个子表达式是零宽度的。</p>
<p>占有字符是互斥的，零宽度是非互斥的。也就是一个字符，同一时间只能由一个子表达式匹配，而一个位置，却可以同时由多个零宽度的子表达式匹配。</p>
<h3 id="33-控制权和传动">3.3  控制权和传动</h3>
<p>正则的匹配过程，通常情况下都是由一个子表达式（可能为一个普通字符、元字符或元字符序列组成）取得控制权，从字符串的某一位置开始尝试匹配，一个子表达式开始尝试匹配的位置，是从前一子表达匹配成功的结束位置开始的。如正则表达式：</p>
<p><strong>(子表达式一)(子表达式二)</strong></p>
<p>假设**(子表达式一)<strong>为零宽度表达式，由于它匹配开始和结束的位置是同一个，如位置0，那么</strong>(子表达式二)**是从位置0开始尝试匹配的。</p>
<p>假设**(子表达式一)<strong>为占有字符的表达式，由于它匹配开始和结束的位置不是同一个，如匹配成功开始于位置0，结束于位置2，那么</strong>(子表达式二)**是从位置2开始尝试匹配的。</p>
<p>而对于整个表达式来说，通常是由字符串位置0开始尝试匹配的。如果在位置0开始的尝试，匹配到字符串某一位置时整个表达式匹配失败，那么引擎会使正则向前传动，整个表达式从位置1开始重新尝试匹配，依此类推，直到报告匹配成功或尝试到最后一个位置后报告匹配失败。</p>
<h3 id="4-正则表达式简单匹配过程">4、正则表达式简单匹配过程</h3>
<h4 id="41-基础匹配过程">4.1 基础匹配过程</h4>
<p>原字符串：<strong>reg</strong></p>
<p>正则表达式：/reg/</p>
<p>匹配过程：由字符r取得控制权，从位置0开始匹配，由r来匹配<strong>r</strong>，匹配成功，控制权交给字符e，因为之前字符r从位置0已经匹配成功，所以字符e从位置1开始匹配，e匹配<strong>e</strong>，匹配成功，接着到字符g匹配<strong>g</strong>，也匹配成功。</p>
<p>正则表达式匹配完成，匹配结果为<strong>reg</strong>，开始位置0，结束位置3。</p>
<h4 id="42-含有量词的匹配过程1">4.2 含有量词的匹配过程（1）</h4>
<p>原字符串：<strong>reg</strong></p>
<p>正则表达式：/re?g/</p>
<p>量词?属于优先匹配量词，在可匹配可不匹配时，会优先选择尝试匹配，当这种选择使得整个表达式无法匹配成功时，才会让出匹配的内容。</p>
<p>匹配过程：由字符r取得控制权，从位置0开始匹配，r匹配<strong>r</strong>，匹配成功，控制权交给e?，e?尝试优先匹配<strong>e</strong>，匹配成功，控制权交给g，且保留一个备选状态，最后由g匹配<strong>g</strong>，匹配成功，丢弃备选状态，匹配结束。</p>
<h4 id="43-含有量词的匹配过程2">4.3 含有量词的匹配过程（2）</h4>
<p>原字符串：<strong>rg</strong></p>
<p>正则表达式：/re?g/</p>
<p>匹配过程：由字符r取得控制权，从位置0开始匹配，r匹配<strong>r</strong>，匹配成功，控制权交给e?，e?匹配g，匹配失败，保留一个备选状态，由于匹配失败，进行回溯，找到备选状态，此时控制权到g，字符g匹配<strong>g</strong>，匹配成功。</p>
<h4 id="44-含有量词的匹配过程3">4.4 含有量词的匹配过程（3）</h4>
<p>原字符串：<strong>reg</strong></p>
<p>正则表达式：/re?x/</p>
<p>匹配过程：由字符r取得控制权，从位置0开始匹配，r匹配<strong>r</strong>，匹配成功，控制权交给e?，e?尝试优先匹配<strong>e</strong>，匹配成功，控制权交给x，且保留一个备选状态，x匹配g，匹配失败，此时进行回溯，找到记录的备选状态，此时控制权交给x，x匹配<strong>e</strong>，匹配失败，第一轮匹配失败。</p>
<p>正则引擎使正则向前传动，由位置1开始尝试匹配，由r匹配<strong>e</strong>，匹配失败，没有备选状态，第二轮匹配尝试失败。正则引擎继续向前传动，知道位置3匹配失败，匹配结束，此时整个正则表达式匹配失败。</p>
<h4 id="45-零宽度匹配过程">4.5 零宽度匹配过程</h4>
<p>源字符串：<strong>a12</strong></p>
<p>正则表达式：^(?=[a-z])[a-z0-9]+$</p>
<p>元字符^和$匹配的只是位置，顺序环视(?=[a-z])只进行匹配，并不占有字符，也不将匹配的内容保存到最终的匹配结果，所以都是零宽度的。</p>
<p>匹配过程：从元字符^开始，匹配位置0，匹配成功，控制权交给顺序环视(?=[a-z])；</p>
<p>(?=[a-z])要求它所在位置右侧必须是字母才能匹配成功，零宽度的子表达式之间是不互斥的，即同一个位置可以同时由多个零宽度子表达式匹配，所以它也是从位置0尝试进行匹配，位置0的右侧是字符“<strong>a</strong>”，符合要求，匹配成功，控制权交给[a-z0-9]+；</p>
<p>因为(?=[a-z])只进行匹配，并不将匹配到的内容保存到最后结果，并且(?=[a-z])匹配成功的位置是位置0，所以[a-z0-9]+也是从位置0开始尝试匹配的，[a-z0-9]+首先尝试匹配a，匹配成功，继续尝试匹配，可以成功匹配接下来的1和2，此时已经匹配到位置3，位置3的右侧已没有字符，这时会把控制权交给$；</p>
<p>$匹配结束位置，也就是位置3，匹配成功。</p>
<p>参考资料：</p>
<p>1、<a href="https://zh.wikipedia.org/wiki/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F" target="_blank" rel="external">正则表达式—wiki</a></p>
<p>2、<a href="https://www.teakki.com/p/57e237c5104112321cd7c85e" target="_blank" rel="external">正则表达式匹配解析过程探讨分析</a></p>
<p>3、<a href="http://blog.csdn.net/lxcnn/article/details/4304651" target="_blank" rel="external">正则基础之——NFA引擎匹配原理</a></p>
<p>4、<a href="http://www.jianshu.com/p/50a4aa64087e" target="_blank" rel="external">正则表达式的原理</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-为什么要知道些正则匹配原理&quot;&gt;1、为什么要知道些正则匹配原理&lt;/h3&gt;
&lt;p&gt;知其然，知其所以然。&lt;/p&gt;
&lt;h3 id=&quot;2-正则匹配引擎&quot;&gt;2、正则匹配引擎&lt;/h3&gt;
&lt;p&gt;正则引擎大体上可分为不同的两类：DFA和NFA。DFA(Deterministic
    
    </summary>
    
    
      <category term="正则原理" scheme="http://keminu.com/tags/%E6%AD%A3%E5%88%99%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>精通JavaScript正则之正则基础</title>
    <link href="http://keminu.com/2017/11/05/%E7%B2%BE%E9%80%9AJavaScript%E6%AD%A3%E5%88%99%E4%B9%8B%E6%AD%A3%E5%88%99%E5%9F%BA%E7%A1%80/"/>
    <id>http://keminu.com/2017/11/05/精通JavaScript正则之正则基础/</id>
    <published>2017-11-05T13:23:08.000Z</published>
    <updated>2017-11-05T13:32:07.164Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1正则结构定义">1.正则结构定义</h3>
<p>有两种方式可以定义一个正则表达式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var reg = /pattern/;</div></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var reg = new RegExp(&apos;pattern&apos;);  // 动态匹配</div></pre></td></tr></table></figure>
<h3 id="2正则标识">2.正则标识</h3>
<table>
<thead>
<tr>
<th>标识</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>g</td>
<td>全局（匹配多次；不同的方法对g标识的处理不同）</td>
</tr>
<tr>
<td>i</td>
<td>忽略字符的大小写</td>
</tr>
<tr>
<td>m</td>
<td>匹配多行（在此标识下，^和$能匹配行结束符）</td>
</tr>
</tbody>
</table>
<h3 id="3正则对象属性">3.正则对象属性</h3>
<table>
<thead>
<tr>
<th>属性</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>global</td>
<td>如果标识 g 被使用，值为true</td>
</tr>
<tr>
<td>source</td>
<td>正则表达式源码文本</td>
</tr>
<tr>
<td>ignoreCase</td>
<td>如果标识 i 被使用，值为true</td>
</tr>
<tr>
<td>lastIndex</td>
<td>下一次exec匹配开始的索引。初始值为0</td>
</tr>
<tr>
<td>multiline</td>
<td>如果标识 m 被使用，值为true</td>
</tr>
</tbody>
</table>
<h3 id="4元字符">4.元字符</h3>
<p>字符的类集，比如不确定的数字、任意字符、空白符、结束符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 匹配数字:  \d</div><div class="line">&quot;ad3ad2ad&quot;.match(/\d/g);  // [&quot;3&quot;, &quot;2&quot;]</div><div class="line"></div><div class="line">// 匹配除换行符以外的任意字符:  .</div><div class="line">&quot;a\nb\rc&quot;.match(/./g);  // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</div><div class="line"></div><div class="line">// 匹配字母或数字或下划线 ： \w</div><div class="line">&quot;a5_  汉字@!-=&quot;.match(/\w/g);  // [&quot;a&quot;, &quot;5&quot;, &quot;_&quot;]</div><div class="line"></div><div class="line">// 匹配元音字母的字符组</div><div class="line">&quot;adefglhi&quot;.match(/[aeiou]/g); // [&quot;a&quot;, &quot;e&quot;, &quot;i&quot;, ]</div></pre></td></tr></table></figure>
<p>注意，在字符组内部，一个^表示的是排除组内字符，并不是匹配行开始，就像’|'、-'一样，在字符组内外有着不同的含义</p>
<p>字符组与多选结构的区别：
字符组里面只匹配单个的字符，而多选结构本身就是一个正则</p>
<h3 id="5量词">5.量词</h3>
<p>每一个正则因子都可以用一个正则量词后缀来决定这个因子因该被匹配的次数。包围在一对花括号中的一个数字表示这个因子因该被匹配的次数。？号表示可选，就等同于{0, 1}，*等同于{0, }，+则等同于{1, }。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// 重复0次或多次</div><div class="line">&quot;test&quot;.match(/test\d*/); // [&quot;test&quot;]</div><div class="line">&quot;test123&quot;.match(/test\d*/); // [&quot;test123&quot;]</div></pre></td></tr></table></figure>
<p>从上面的结果可以看到正则匹配的子字符串会尽可能返回多的数字，这就是在满足条件的情况下捕获尽可能多的字符-贪婪模式。</p>
<p>对应的”懒惰模式“，就是在满足条件的情况下捕获尽可能少的字符串，使用懒惰模式的方法，就是在字符重复标识后面加上一个 &quot;?&quot;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 数字重复3~5次，满足条件的情况下返回尽可能少的数字</div><div class="line">&quot;test12345&quot;.match(/test\d&#123;3,5&#125;?/);  // [&quot;test123&quot;]</div><div class="line">// 数字重复1次或更多，满足条件的情况下只返回一个数字</div><div class="line">&quot;test12345&quot;.match(/test\d+?/);  // [&quot;test1&quot;]</div></pre></td></tr></table></figure>
<h3 id="6字符转义">6.字符转义</h3>
<p>在正则表达式中元字符是有特殊的含义的，当我们要匹配元字符本身时，就需要用到字符转义。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/\./.test(&quot;.&quot;); // true</div></pre></td></tr></table></figure>
<h3 id="7分支">7.分支</h3>
<p>当正则表达式需要匹配几种类型的结果时，可以用到分支</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&quot;asdasd hi  asdad hello asdasd&quot;.replace(/hi|hello/,&quot;nihao&quot;); // &quot;asdasd nihao  asdad hello asdasd&quot;</div><div class="line"></div><div class="line">&quot;asdasd hi  asdad hello asdasd&quot;.split(/hi|hello/); // [&quot;asdasd &quot;, &quot;  asdad &quot;, &quot; asdasd&quot;]</div></pre></td></tr></table></figure>
<p>分支条件影响它两边的所有内容， 比如 hi|hello  匹配的是hi或者hello，而不是 hiello 或者 hhello。
分组中的分支条件不会影响分组外的内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&quot;abc acd  bbc bcd &quot;.match(/(a|b)bc/g); // [&quot;abc&quot;, &quot;bbc&quot;]</div></pre></td></tr></table></figure>
<h3 id="8分组">8.分组</h3>
<p>捕获型：一个捕获型分组是一个被包围在圆括号中的正则表达式分支。任何匹配这个分组的字符都会被捕获。每个捕获型分组都被指定了一个数字代表分组号。</p>
<p>非捕获型：非捕获型分组有一个(?:前缀。非捕获型分组仅做简单的匹配，并不会捕获所匹配的文本，也不会干扰捕获型分组的编号。</p>
<p>向前正向匹配：向前正向匹配分组有一个(?=前缀，类似于非捕获型分组，实际上不捕获任何匹配文本，也不分配组号。在这个组匹配后，文本会倒回到它开始的地方。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/hello\s(?=world)/.exec(&quot;asdadasd hello world asdasd&quot;)  // [&quot;hello &quot;]</div></pre></td></tr></table></figure>
<p>向前负向匹配：向前负向匹配分组有一个(?!前缀。它也类似于非捕获型分组，不捕获任何匹配文本，不分配组号。只有当它匹配失败时才继续向前匹配。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/hello\s(?!world)/.exec(&quot;asdadasd hello world asdasd&quot;) // null</div></pre></td></tr></table></figure>
<h3 id="9后向引用">9.后向引用</h3>
<p>正则表达式的分组可以在其后边的语句中通过 \ 紧接着一个数字组号来引用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 匹配重复的单词</div><div class="line">/(\b[a-zA-Z]+\b)\s+\1/.exec(&quot; asd sf  hello hello asd&quot;); // [&quot;hello hello&quot;, &quot;hello&quot;]</div></pre></td></tr></table></figure>
<h3 id="10方法">10.方法</h3>
<h3 id="regexpprototypetest">RegExp.prototype.test</h3>
<p>用来测试字符串中是否含有子字符串</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/hello/.test(&quot;abchello&quot;);  // true</div></pre></td></tr></table></figure>
<h3 id="regexpprototypeexec">RegExp.prototype.exec</h3>
<p>这个方法从字符串中捕获满足条件的字符串到结果数组中，值得注意的是，这个方法一次只能捕获一份子字符串到结果数组中，无论正则表达式是否有全局属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var reg=/hello/g;</div><div class="line">reg.exec(&quot;abchelloasdasdhelloasd&quot;);   // [&quot;hello&quot;]</div></pre></td></tr></table></figure>
<p>如何做全局匹配？</p>
<p>在正则表达式中有分组的情况下，无论正则表达式是否有全局属性，exec函数都只返回一个结果，并捕获分组的结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/h(ell)o/g.exec(&quot;abchellodefhellog&quot;); // [&quot;hello&quot;, &quot;ell&quot;]</div></pre></td></tr></table></figure>
<h3 id="stringprototypesearch">String.prototype.search</h3>
<p>用来找出原字符串中某个子字符串首次出现的index，没有则返回-1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&quot;abchello&quot;.search(/hello/);  // 3</div></pre></td></tr></table></figure>
<h3 id="stringprototypereplace">String.prototype.replace</h3>
<p>用来替换字符串中的子串</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&quot;abchello&quot;.replace(/hello/,&quot;hi&quot;);   // &quot;abchi&quot;</div></pre></td></tr></table></figure>
<p>正则表达式存在分组的情况下，第二个参数里边可以用 $ 紧接着一个数字组号来指代第几个分组的内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&quot; the best language in the world is java &quot;.replace(/(java)/,&quot;$1script&quot;); // &quot; the best language in the world is javascript &quot;</div></pre></td></tr></table></figure>
<h3 id="stringprototypesplit">String.prototype.split</h3>
<p>用来分割字符串</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&quot;abchelloasdasdhelloasd&quot;.split(/hello/);  // [&quot;abc&quot;, &quot;asdasd&quot;, &quot;asd&quot;]</div></pre></td></tr></table></figure>
<h3 id="stringprototypematch">String.prototype.match</h3>
<p>用来捕获字符串中的子字符串到一个数组中。默认情况下只捕获一个结果到数组中，正则表达式有”全局捕获“的属性时(定义正则表达式的时候添加参数g)，会捕获所有结果到数组中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&quot;ahelloasdasdhelloasd&quot;.match(/hello/);  // [&quot;hello&quot;]</div><div class="line"></div><div class="line">&quot;ahelloasdasdhelloasd&quot;.match(/hello/g);  // [&quot;hello&quot;,&quot;hello&quot;]</div></pre></td></tr></table></figure>
<p>当没有全局属性，但是正则表达式有分组时，会返回分组匹配结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&quot;abchellodefhellog&quot;.match(/h(ell)o/); // [&quot;hello&quot;, &quot;ell&quot;]</div></pre></td></tr></table></figure>
<h2 id="一个例子">一个例子</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var parse_url = /^(?:([A-Za-z]+):)?(\/&#123;0,3&#125;)([0-9.\-A-Za-z]+)(?::(\d+))?(?:\/([^?#]*))?(?:\?([^#]*))?(?:#(.*))?$/;</div></pre></td></tr></table></figure>
<h2 id="one-more-thing">One more thing...</h2>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1正则结构定义&quot;&gt;1.正则结构定义&lt;/h3&gt;
&lt;p&gt;有两种方式可以定义一个正则表达式&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;
    
    </summary>
    
    
      <category term="正则表达式" scheme="http://keminu.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>数据双向绑定</title>
    <link href="http://keminu.com/2017/11/05/%E6%95%B0%E6%8D%AE%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/"/>
    <id>http://keminu.com/2017/11/05/数据双向绑定/</id>
    <published>2017-11-05T13:05:01.000Z</published>
    <updated>2017-11-05T13:21:33.978Z</updated>
    
    <content type="html"><![CDATA[<!-- toc -->
<ul>
<li><a href="#1%E6%88%91%E4%BB%AC%E8%A6%81%E5%81%9A%E4%BB%80%E4%B9%88">1.我们要做什么</a></li>
<li><a href="#2objectdefineproperty">2.Object.defineProperty()</a></li>
<li><a href="#3%E4%BF%9D%E5%AD%98%E6%97%A7%E5%80%BC">3.保存旧值</a></li>
<li><a href="#4%E7%9B%91%E6%B5%8B%E6%95%B0%E7%BB%84%E5%8F%98%E5%8C%96">4.监测数组变化</a></li>
<li><a href="#5%E6%A8%A1%E6%9D%BF%E6%98%A0%E5%B0%84">5.模板映射</a></li>
</ul>
<!-- tocstop -->
<h3 id="1我们要做什么">1.我们要做什么</h3>
<p>实现一个迷你库，检测一组数据的变化，当数据变化的时候，做出响应。大致像下面的使用方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">// 定义一个变化通知的回调</div><div class="line">var callback = function(newVal, oldVal)&#123;</div><div class="line">    alert(newVal + &apos;----&apos; + oldVal);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 定义一个普通对象作为数据模型</div><div class="line">var data = &#123;</div><div class="line">    a: 200,</div><div class="line">    level1: &#123;</div><div class="line">        b: &apos;str&apos;,</div><div class="line">        c: [1, 2, 3],</div><div class="line">        level2: &#123;</div><div class="line">            d: 90</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 实例化一个监测对象，去监测数据，并在数据发生改变的时候作出反应</div><div class="line">var v = new Mvvm(data, callback);</div></pre></td></tr></table></figure>
<p>怎么实现？</p>
<h3 id="2objectdefineproperty">2.Object.defineProperty()</h3>
<p>我们可以使用下面的方式定义一个对象，并给对象添加一个属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var obj = &#123;&#125;;</div><div class="line"></div><div class="line">obj.name = &apos;hcy&apos;;</div></pre></td></tr></table></figure>
<p>也可以使用Object.defineProperty()给对象添加属性，上面的代码等价于</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var obj = &#123;&#125;;</div><div class="line"></div><div class="line">Object.defineProperty(obj, &apos;name&apos;, &#123;</div><div class="line">	value: &apos;hcy&apos;,		// 属性的值</div><div class="line">	writable: true,		// 是否可写</div><div class="line">	enumerable: true,	// 是否能够通过for in 枚举</div><div class="line">	configurable: true	// 是否可使用 delete删除</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>这样定义的属性是数据属性，用来描述数据。还有另外一个访问器属性，允许你定义一对儿 getter/setter ，当你读取属性值的时候底层会调用 get 方法，当你去设置属性值的时候，底层会调用 set 方法。</p>
<p>这简直太美妙了，这不正是我们想要的吗？</p>
<p>遍历对象的属性，把对象的属性都使用 Object.defineProperty 转为 getter/setter ，这样，当我们修改一些值得时候，就会调用set方法，然后我们在set方法里面，回调通知，这样不就可以了吗？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">const OP = Object.prototype;</div><div class="line"></div><div class="line">class Mvvm&#123;</div><div class="line">    constructor(obj, callback)&#123;</div><div class="line">        if(OP.toString.call(obj) !== &apos;[object Object]&apos;)&#123;</div><div class="line">            console.error(&apos;This parameter must be an object：&apos; + obj);</div><div class="line">        &#125;</div><div class="line">        this.$callback = callback;</div><div class="line">        this.observe(obj);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    observe(obj)&#123;</div><div class="line">        Object.keys(obj).forEach(function(key, index, keyArray)&#123;</div><div class="line">            var val = obj[key];</div><div class="line">            Object.defineProperty(obj, key, &#123;</div><div class="line">                get: function()&#123;</div><div class="line">                    return val;</div><div class="line">                &#125;,</div><div class="line">                set: (function(newVal)&#123;</div><div class="line">                    this.$callback(newVal);</div><div class="line">                &#125;).bind(this)</div><div class="line">            &#125;);</div><div class="line">            </div><div class="line">            if(OP.toString.call(obj[key]) === &apos;[object Object]&apos;)&#123;</div><div class="line">                this.observe(obj[key]);</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">        &#125;, this);</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="https://jsfiddle.net/keminu/8x3ou6pL/1/" target="_blank" rel="external">测试一下我们的代码</a></p>
<h3 id="3保存旧值">3.保存旧值</h3>
<p>现在我们成功的监测到数据变化并且做出响应了。但是这个响应只处理了新值，有时候我们是需要旧值的，现在我们的代码还无法传递旧值，怎么改？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">var oldVal = obj[key];</div><div class="line">Object.defineProperty(obj, key, &#123;</div><div class="line">    get: function()&#123;</div><div class="line">        return oldVal;</div><div class="line">    &#125;,</div><div class="line">    set: (function(newVal)&#123;</div><div class="line">        if(oldVal !== newVal)&#123;</div><div class="line">            if(OP.toString.call(newVal) === &apos;[object Object]&apos;)&#123;</div><div class="line">                this.observe(newVal);</div><div class="line">            &#125;</div><div class="line">            this.$callback(newVal, oldVal);</div><div class="line">            oldVal = newVal;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">    &#125;).bind(this)</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><a href="https://jsfiddle.net/9hsuz6wa/" target="_blank" rel="external">看下效果</a></p>
<h3 id="4监测数组变化">4.监测数组变化</h3>
<p>这样子看上去还不错了哦，我们能够监测到数据的变化，拿到了新旧数据。但是这样就完了吗？</p>
<p>遗憾的是我们还不能监测到数组的变化。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">data.level1.c.push(4);</div></pre></td></tr></table></figure>
<p>有什么思路可以解决这个问题？
重写原型方法可以吗？像是这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Array.prototype.push = function()&#123;</div><div class="line">    // 数据观察</div><div class="line">&#125;</div><div class="line">Array.prototype.pop = function()&#123;</div><div class="line">    // 数据观察</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>暂且不说能不能全部实现的与原生无异，即使你实现的与原生方法在使用方式上一模一样，并且不影响其他代码的运行，那么在性能上，可能就与原生差很多了，重新考虑，我们可不可以在原型链中加一层fakePrototype，在使用 push 等数组方法的时候，调用的是 fakePrototype 上的push方法，然后在 fakePrototype 方法中再去调用真正的Array原型上的 push 方法，同时监听变化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> *  Object 原型</div><div class="line"> */</div><div class="line">const OP = Object.prototype;</div><div class="line">/*</div><div class="line"> *  需要重写的数组方法 OAR 是 overrideArrayMethod 的缩写</div><div class="line"> */</div><div class="line">const OAM = [&apos;push&apos;, &apos;pop&apos;, &apos;shift&apos;, &apos;unshift&apos;, &apos;splice&apos;, &apos;sort&apos;, &apos;reverse&apos;];</div><div class="line"></div><div class="line">class Mvvm&#123;</div><div class="line">    constructor(obj, callback)&#123;</div><div class="line">        if(OP.toString.call(obj) !== &apos;[object Object]&apos;)&#123;</div><div class="line">            console.error(&apos;This parameter must be an object：&apos; + obj);</div><div class="line">        &#125;</div><div class="line">        this.$callback = callback;</div><div class="line">        this.observe(obj);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    observe(obj)&#123;</div><div class="line">        // 如果发现 监测的对象是数组的话就要调用 overrideArrayProto 方法</div><div class="line">        if(OP.toString.call(obj) === &apos;[object Array]&apos;)&#123;</div><div class="line">            this.overrideArrayProto(obj);</div><div class="line">        &#125;</div><div class="line">        Object.keys(obj).forEach(function(key, index, keyArray)&#123;</div><div class="line">            var oldVal = obj[key];</div><div class="line">            Object.defineProperty(obj, key, &#123;</div><div class="line">                get: function()&#123;</div><div class="line">                    return oldVal;</div><div class="line">                &#125;,</div><div class="line">                set: (function(newVal)&#123;</div><div class="line">                    if(oldVal !== newVal)&#123;</div><div class="line">                        if(OP.toString.call(newVal) === &apos;[object Object]&apos; || OP.toString.call(newVal) === &apos;[object Array]&apos;)&#123;</div><div class="line">                            this.observe(newVal);</div><div class="line">                        &#125;</div><div class="line">                        this.$callback(newVal, oldVal);</div><div class="line">                        oldVal = newVal;</div><div class="line">                    &#125;</div><div class="line">                    </div><div class="line">                &#125;).bind(this)</div><div class="line">            &#125;);</div><div class="line">            </div><div class="line">            if(OP.toString.call(obj[key]) === &apos;[object Object]&apos; || OP.toString.call(obj[key]) === &apos;[object Array]&apos;)&#123;</div><div class="line">                this.observe(obj[key]);</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">        &#125;, this);</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    overrideArrayProto(array)&#123;</div><div class="line">            // 保存原始 Array 原型</div><div class="line">        var originalProto = Array.prototype,</div><div class="line">            // 通过 Object.create 方法创建一个对象，该对象的原型就是Array.prototype</div><div class="line">            overrideProto = Object.create(Array.prototype),</div><div class="line">            self = this,</div><div class="line">            result;</div><div class="line">        // 遍历要重写的数组方法</div><div class="line">        Object.keys(OAM).forEach(function(key, index, array)&#123;</div><div class="line">            var method = OAM[index],</div><div class="line">                oldArray = [];</div><div class="line">            // 使用 Object.defineProperty 给 overrideProto 添加属性，属性的名称是对应的数组函数名，值是函数</div><div class="line">            Object.defineProperty(overrideProto, method, &#123;</div><div class="line">                value: function()&#123;</div><div class="line">                    oldArray = this.slice(0);</div><div class="line">                    </div><div class="line">                    var arg = [].slice.apply(arguments);</div><div class="line">                    // 调用原始 原型 的数组方法</div><div class="line">                    result = originalProto[method].apply(this, arg);</div><div class="line">                    // 对新的数组进行监测</div><div class="line">                    self.observe(this);</div><div class="line">                    // 执行回调</div><div class="line">                    self.$callback(this, oldArray);</div><div class="line">                    </div><div class="line">                    return result;</div><div class="line">                &#125;,</div><div class="line">                writable: true,</div><div class="line">                enumerable: false,</div><div class="line">                configurable: true</div><div class="line">            &#125;);</div><div class="line">        &#125;, this);</div><div class="line">        </div><div class="line">        // 最后 让该数组实例的 __proto__ 属性指向 假的原型 overrideProto</div><div class="line">        array.__proto__ = overrideProto;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="https://jsfiddle.net/keminu/Lv2ycLww/" target="_blank" rel="external">看下效果</a></p>
<h3 id="5模板映射">5.模板映射</h3>
<p>现在，我们可以几乎完美的监测到数据对象的变化了，并且能够知道变化前后的旧值与新值，那么这样就结束了吗？当然不是，我们现在并不知道修改的是哪个属性，但是能够知道修改的是哪个属性是非常重要的。比如，我们有如下的模板：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;div id="box"&gt;</div><div class="line">    &lt;div&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt;</div><div class="line">    &lt;div&gt;&#123;&#123;age&#125;&#125;&lt;/div&gt;</div><div class="line">    &lt;div&gt;&#123;&#123;sex&#125;&#125;&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<p>然后有如下的数据：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> data = &#123;</div><div class="line">    <span class="attr">name</span> : <span class="string">'nuoka'</span>,</div><div class="line">    <span class="attr">age</span> : <span class="number">20</span>,</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们想通过这种方式反应模板与数据之间的关系：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Mvvm(<span class="built_in">document</span>.getElementById(<span class="string">'box'</span>), data);</div></pre></td></tr></table></figure>
<p>那么当我们的数据模型data中的某个属性改变的时候，比如 data.name = ‘kage’，如若我们不知道改变的字段名称，那么我们就无法得知要刷新哪部分模板。</p>
<p>那么这里就有一个路径的概念，所谓路径，就是变化的字段的路径，比如有如下数据模型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var data = &#123;</div><div class="line">    a : &#123;</div><div class="line">        b : &#123;</div><div class="line">            c : &apos;hcy&apos;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么字段 a 的路径就是用 data.a ，b 的路径就是 data.a.b，c 的路径就是 data.a.b.c，这里我们用数组来表述路径可以是这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1、 a 的路径是 [‘data’, ‘a’]</div><div class="line">2、 b 的路径是 [‘data’, ‘a’, ‘b’]</div><div class="line">3、 c 的路径是 [‘data’, ‘a’, ‘b’, ‘c’]</div></pre></td></tr></table></figure>
<p>有了这个概念之后，我们来修改之前的代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line">observe(obj, path)&#123;</div><div class="line">        // 如果发现 监测的对象是数组的话就要调用 overrideArrayProto 方法</div><div class="line">        if(OP.toString.call(obj) === &apos;[object Array]&apos;)&#123;</div><div class="line">            this.overrideArrayProto(obj, path);</div><div class="line">        &#125;</div><div class="line">        Object.keys(obj).forEach(function(key, index, keyArray)&#123;</div><div class="line">            var oldVal = obj[key];</div><div class="line">            </div><div class="line">            var pathArray = path &amp;&amp; path.slice(0);</div><div class="line">            if (pathArray) &#123;</div><div class="line">                pathArray.push(key);</div><div class="line">            &#125; else &#123;</div><div class="line">                pathArray = [key];</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            Object.defineProperty(obj, key, &#123;</div><div class="line">                get: function()&#123;</div><div class="line">                    return oldVal;</div><div class="line">                &#125;,</div><div class="line">                set: (function(newVal)&#123;</div><div class="line">                    if(oldVal !== newVal)&#123;</div><div class="line">                        if(OP.toString.call(newVal) === &apos;[object Object]&apos; || OP.toString.call(newVal) === &apos;[object Array]&apos;)&#123;</div><div class="line">                            this.observe(newVal, pathArray);</div><div class="line">                        &#125;</div><div class="line">                        this.$callback(newVal, oldVal, pathArray);</div><div class="line">                        oldVal = newVal;</div><div class="line">                    &#125;</div><div class="line">                    </div><div class="line">                &#125;).bind(this)</div><div class="line">            &#125;);</div><div class="line">            </div><div class="line">            if(OP.toString.call(obj[key]) === &apos;[object Object]&apos; || OP.toString.call(obj[key]) === &apos;[object Array]&apos;)&#123;</div><div class="line">                this.observe(obj[key], pathArray);</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">        &#125;, this);</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    overrideArrayProto(array, path)&#123;</div><div class="line">            // 保存原始 Array 原型</div><div class="line">        var originalProto = Array.prototype,</div><div class="line">            // 通过 Object.create 方法创建一个对象，该对象的原型就是Array.prototype</div><div class="line">            overrideProto = Object.create(Array.prototype),</div><div class="line">            self = this,</div><div class="line">            result;</div><div class="line">        // 遍历要重写的数组方法</div><div class="line">        Object.keys(OAM).forEach(function(key, index, array)&#123;</div><div class="line">            var method = OAM[index],</div><div class="line">                oldArray = [];</div><div class="line">            // 使用 Object.defineProperty 给 overrideProto 添加属性，属性的名称是对应的数组函数名，值是函数</div><div class="line">            Object.defineProperty(overrideProto, method, &#123;</div><div class="line">                value: function()&#123;</div><div class="line">                    oldArray = this.slice(0);</div><div class="line">                    </div><div class="line">                    var arg = [].slice.apply(arguments);</div><div class="line">                    // 调用原始 原型 的数组方法</div><div class="line">                    result = originalProto[method].apply(this, arg);</div><div class="line">                    // 对新的数组进行监测</div><div class="line">                    self.observe(this, path);</div><div class="line">                    // 执行回调</div><div class="line">                    self.$callback(this, oldArray, path);</div><div class="line">                    </div><div class="line">                    return result;</div><div class="line">                &#125;,</div><div class="line">                writable: true,</div><div class="line">                enumerable: false,</div><div class="line">                configurable: true</div><div class="line">            &#125;);</div><div class="line">        &#125;, this);</div><div class="line">        </div><div class="line">        // 最后 让该数组实例的 __proto__ 属性指向 假的原型 overrideProto</div><div class="line">        array.__proto__ = overrideProto;</div><div class="line">        </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><a href="https://jsfiddle.net/keminu/o0zavhy9/" target="_blank" rel="external">最后再尝试下修改数组属性</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1%E6%88%91%E4%BB%AC%E8%A6%81%E5%81%9A%E4%BB%80%E4%B9%88&quot;&gt;1.我们要做什么&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2objectdefineproper
    
    </summary>
    
    
      <category term="vue" scheme="http://keminu.com/tags/vue/"/>
    
      <category term="响应式原理" scheme="http://keminu.com/tags/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>在工作遇到的IE8兼容性问题</title>
    <link href="http://keminu.com/2016/07/02/%E5%9C%A8%E5%B7%A5%E4%BD%9C%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84IE8%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98/"/>
    <id>http://keminu.com/2016/07/02/在工作中遇到的IE8兼容性问题/</id>
    <published>2016-07-02T12:33:30.000Z</published>
    <updated>2017-05-30T13:35:40.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc -->
<ul>
<li><a href="#1-ie8%E4%B8%8D%E5%85%BC%E5%AE%B9es5%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B9%E6%B3%95%E6%AF%94%E5%A6%82indexoflastindexoffilter%E7%AD%89%E7%AD%89">1、IE8不兼容ES5的一些方法，比如indexOf,lastIndexOf,filter等等</a></li>
<li><a href="#2-ie8%E4%B8%8D%E5%85%BC%E5%AE%B9opacity-rgba%E5%B1%9E%E6%80%A7">2、IE8不兼容opacity、rgba属性</a></li>
<li><a href="#3-ie8%E4%B8%8D%E5%85%BC%E5%AE%B9border-radius%E5%B1%9E%E6%80%A7">3、IE8不兼容border-radius属性</a></li>
</ul>
<!-- tocstop -->
<h2 id="1-ie8不兼容es5的一些方法比如indexoflastindexoffilter等等">1、IE8不兼容ES5的一些方法，比如indexOf,lastIndexOf,filter等等</h2>
<p>解决方法：添加es5-shim.js脚本，在github搜索相应关键字。</p>
<h2 id="2-ie8不兼容opacity-rgba属性">2、IE8不兼容opacity、rgba属性</h2>
<p>解决方法：使用ie的过滤器filter</p>
<h2 id="3-ie8不兼容border-radius属性">3、IE8不兼容border-radius属性</h2>
<p>尝试使用border-radius.htc这个hack，但是还是没有效果，暂时还不知道是什么原因。
又尝试使用jquery.corner.js，还是没有解决。</p>
]]></content>
    
    <summary type="html">
    
      一些在工作过程中遇到的IE8兼容性问题，以及相应的解决方案。
    
    </summary>
    
      <category term="IE8兼容性" scheme="http://keminu.com/categories/IE8%E5%85%BC%E5%AE%B9%E6%80%A7/"/>
    
    
      <category term="css" scheme="http://keminu.com/tags/css/"/>
    
      <category term="IE8兼容性" scheme="http://keminu.com/tags/IE8%E5%85%BC%E5%AE%B9%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>你为什么要开始写博客</title>
    <link href="http://keminu.com/2016/06/26/%E4%BD%A0%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%BC%80%E5%A7%8B%E5%86%99%E5%8D%9A%E5%AE%A2/"/>
    <id>http://keminu.com/2016/06/26/你为什么要开始写博客/</id>
    <published>2016-06-26T08:33:30.000Z</published>
    <updated>2017-11-05T13:08:39.802Z</updated>
    
    <content type="html"><![CDATA[<!-- toc -->
<ul>
<li><a href="#1-%E6%80%BB%E7%BB%93%E8%87%AA%E5%B7%B1%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%94%9F%E6%B4%BB">1、总结自己的学习生活</a></li>
<li><a href="#2-%E8%AE%A9%E5%88%AB%E4%BA%BA%E6%9B%B4%E5%8A%A0%E4%BA%86%E8%A7%A3%E8%87%AA%E5%B7%B1">2、让别人更加了解自己</a></li>
<li><a href="#3-%E5%86%99%E5%8D%9A%E5%AE%A2%E6%98%AF%E8%AE%AD%E7%BB%83%E8%87%AA%E5%B7%B1%E6%80%9D%E7%BB%B4%E7%9A%84%E4%B8%80%E7%A7%8D%E6%96%B9%E5%BC%8F">3、写博客是训练自己思维的一种方式</a></li>
</ul>
<!-- tocstop -->
<h2 id="1-总结自己的学习生活">1、总结自己的学习生活</h2>
<p>把近期学习过的知识再梳理一遍，梳理的过程中会不断的回忆已学知识，会去扩展调查取证来证明自己的观点，这样不仅能够巩固牢记之前所学，还会让自己的逻辑性更强</p>
<h2 id="2-让别人更加了解自己">2、让别人更加了解自己</h2>
<p>在这个互联网时代，要学会展现自己，让不了解自己的人更加的了解自己。博客就是一种很好的方式。</p>
<h2 id="3-写博客是训练自己思维的一种方式">3、写博客是训练自己思维的一种方式</h2>
<p>写出来的博客必须要具有总结性、连贯性、逻辑性。
总结性需要高度的概括能力，精确的提炼关键信息。
连贯性与逻辑性是相辅相成的，连贯性是建立在逻辑性的基础之上，而是否符合逻辑很大程度上取决于知识面，知识面越广，理解越透彻，写出来的文章才不是被他人轻易的推倒。</p>
]]></content>
    
    <summary type="html">
    
      在此写下我开始写博客的几点原由，对自己进行一些总结。
    
    </summary>
    
      <category term="hexo" scheme="http://keminu.com/categories/hexo/"/>
    
    
      <category term="思维方式" scheme="http://keminu.com/tags/%E6%80%9D%E7%BB%B4%E6%96%B9%E5%BC%8F/"/>
    
  </entry>
  
</feed>
